<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="pl" lang="pl"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>file_1653560951327</title><meta name="author" content="Mateusz Kaczmarek"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 h1 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: bold; text-decoration: none; font-size: 16pt; }
 .s1 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 .p, p { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; margin:0pt; }
 .s2 { color: black; font-family:Calibri, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s3 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s4 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s5 { color: #00AF50; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s6 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s7 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s8 { color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11.5pt; }
 .s11 { color: #FFC000; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 .s12 { color: #F00; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l1 {padding-left: 0pt; }
 #l1> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l2 {padding-left: 0pt;counter-reset: d1 1; }
 #l2> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 li {display: block; }
 #l3 {padding-left: 0pt;counter-reset: e1 1; }
 #l3> li>*:first-child:before {counter-increment: e1; content: counter(e1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l3> li:first-child>*:first-child:before {counter-increment: e1 0;  }
 #l4 {padding-left: 0pt;counter-reset: e2 1; }
 #l4> li>*:first-child:before {counter-increment: e2; content: counter(e2, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l4> li:first-child>*:first-child:before {counter-increment: e2 0;  }
 #l5 {padding-left: 0pt;counter-reset: e2 1; }
 #l5> li>*:first-child:before {counter-increment: e2; content: counter(e2, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l5> li:first-child>*:first-child:before {counter-increment: e2 0;  }
 #l6 {padding-left: 0pt; }
 #l6> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l7 {padding-left: 0pt;counter-reset: g1 1; }
 #l7> li>*:first-child:before {counter-increment: g1; content: counter(g1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l7> li:first-child>*:first-child:before {counter-increment: g1 0;  }
 #l8 {padding-left: 0pt; }
 #l8> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l9 {padding-left: 0pt; }
 #l9> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l10 {padding-left: 0pt; }
 #l10> li>*:first-child:before {content: "o "; color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l11 {padding-left: 0pt; }
 #l11> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l12 {padding-left: 0pt; }
 #l12> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l13 {padding-left: 0pt;counter-reset: h1 1; }
 #l13> li>*:first-child:before {counter-increment: h1; content: counter(h1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l13> li:first-child>*:first-child:before {counter-increment: h1 0;  }
 #l14 {padding-left: 0pt;counter-reset: h2 1; }
 #l14> li>*:first-child:before {counter-increment: h2; content: counter(h2, lower-latin)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l14> li:first-child>*:first-child:before {counter-increment: h2 0;  }
 #l15 {padding-left: 0pt;counter-reset: h2 1; }
 #l15> li>*:first-child:before {counter-increment: h2; content: counter(h2, lower-latin)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l15> li:first-child>*:first-child:before {counter-increment: h2 0;  }
 #l16 {padding-left: 0pt;counter-reset: h2 1; }
 #l16> li>*:first-child:before {counter-increment: h2; content: counter(h2, lower-latin)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l16> li:first-child>*:first-child:before {counter-increment: h2 0;  }
 #l17 {padding-left: 0pt;counter-reset: h2 1; }
 #l17> li>*:first-child:before {counter-increment: h2; content: counter(h2, lower-latin)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l17> li:first-child>*:first-child:before {counter-increment: h2 0;  }
 li {display: block; }
 #l18 {padding-left: 0pt;counter-reset: i1 1; }
 #l18> li>*:first-child:before {counter-increment: i1; content: counter(i1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l18> li:first-child>*:first-child:before {counter-increment: i1 0;  }
 #l19 {padding-left: 0pt;counter-reset: i2 1; }
 #l19> li>*:first-child:before {counter-increment: i2; content: counter(i2, lower-latin)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l19> li:first-child>*:first-child:before {counter-increment: i2 0;  }
 #l20 {padding-left: 0pt; }
 #l20> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l21 {padding-left: 0pt; }
 #l21> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l22 {padding-left: 0pt;counter-reset: i2 1; }
 #l22> li>*:first-child:before {counter-increment: i2; content: counter(i2, lower-latin)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l22> li:first-child>*:first-child:before {counter-increment: i2 0;  }
 #l23 {padding-left: 0pt; }
 #l23> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l24 {padding-left: 0pt; }
 #l24> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l25 {padding-left: 0pt;counter-reset: i2 1; }
 #l25> li>*:first-child:before {counter-increment: i2; content: counter(i2, lower-latin)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l25> li:first-child>*:first-child:before {counter-increment: i2 0;  }
 #l26 {padding-left: 0pt; }
 #l26> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l27 {padding-left: 0pt;counter-reset: j1 3; }
 #l27> li>*:first-child:before {counter-increment: j1; content: counter(j1, lower-latin)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l27> li:first-child>*:first-child:before {counter-increment: j1 0;  }
 #l28 {padding-left: 0pt; }
 #l28> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l29 {padding-left: 0pt;counter-reset: i2 1; }
 #l29> li>*:first-child:before {counter-increment: i2; content: counter(i2, lower-latin)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l29> li:first-child>*:first-child:before {counter-increment: i2 0;  }
 #l30 {padding-left: 0pt; }
 #l30> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l31 {padding-left: 0pt; }
 #l31> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l32 {padding-left: 0pt;counter-reset: i2 1; }
 #l32> li>*:first-child:before {counter-increment: i2; content: counter(i2, lower-latin)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l32> li:first-child>*:first-child:before {counter-increment: i2 0;  }
 #l33 {padding-left: 0pt;counter-reset: k1 1; }
 #l33> li>*:first-child:before {counter-increment: k1; content: counter(k1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l33> li:first-child>*:first-child:before {counter-increment: k1 0;  }
 #l34 {padding-left: 0pt; }
 #l34> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l35 {padding-left: 0pt;counter-reset: m1 1; }
 #l35> li>*:first-child:before {counter-increment: m1; content: counter(m1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l35> li:first-child>*:first-child:before {counter-increment: m1 0;  }
 li {display: block; }
 #l36 {padding-left: 0pt;counter-reset: n1 1; }
 #l36> li>*:first-child:before {counter-increment: n1; content: counter(n1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l36> li:first-child>*:first-child:before {counter-increment: n1 0;  }
 #l37 {padding-left: 0pt;counter-reset: n2 1; }
 #l37> li>*:first-child:before {counter-increment: n2; content: counter(n2, lower-latin)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l37> li:first-child>*:first-child:before {counter-increment: n2 0;  }
 #l38 {padding-left: 0pt;counter-reset: n2 1; }
 #l38> li>*:first-child:before {counter-increment: n2; content: counter(n2, lower-latin)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l38> li:first-child>*:first-child:before {counter-increment: n2 0;  }
 #l39 {padding-left: 0pt;counter-reset: o1 1; }
 #l39> li>*:first-child:before {counter-increment: o1; content: counter(o1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l39> li:first-child>*:first-child:before {counter-increment: o1 0;  }
 #l40 {padding-left: 0pt;counter-reset: p1 1; }
 #l40> li>*:first-child:before {counter-increment: p1; content: counter(p1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l40> li:first-child>*:first-child:before {counter-increment: p1 0;  }
 #l41 {padding-left: 0pt; }
 #l41> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l42 {padding-left: 0pt; }
 #l42> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l43 {padding-left: 0pt;counter-reset: s1 1; }
 #l43> li>*:first-child:before {counter-increment: s1; content: counter(s1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l43> li:first-child>*:first-child:before {counter-increment: s1 0;  }
 #l44 {padding-left: 0pt;counter-reset: s2 1; }
 #l44> li>*:first-child:before {counter-increment: s2; content: counter(s2, lower-latin)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l44> li:first-child>*:first-child:before {counter-increment: s2 0;  }
 #l45 {padding-left: 0pt;counter-reset: s2 1; }
 #l45> li>*:first-child:before {counter-increment: s2; content: counter(s2, lower-latin)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l45> li:first-child>*:first-child:before {counter-increment: s2 0;  }
 #l46 {padding-left: 0pt;counter-reset: s2 1; }
 #l46> li>*:first-child:before {counter-increment: s2; content: counter(s2, lower-latin)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l46> li:first-child>*:first-child:before {counter-increment: s2 0;  }
 #l47 {padding-left: 0pt;counter-reset: s2 1; }
 #l47> li>*:first-child:before {counter-increment: s2; content: counter(s2, lower-latin)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l47> li:first-child>*:first-child:before {counter-increment: s2 0;  }
 #l48 {padding-left: 0pt; }
 #l48> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l49 {padding-left: 0pt; }
 #l49> li>*:first-child:before {content: "o "; color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l50 {padding-left: 0pt; }
 #l50> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l51 {padding-left: 0pt; }
 #l51> li>*:first-child:before {content: "o "; color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l52 {padding-left: 0pt; }
 #l52> li>*:first-child:before {content: "o "; color: black; font-family:"Courier New", monospace; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l53 {padding-left: 0pt; }
 #l53> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l54 {padding-left: 0pt; }
 #l54> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l55 {padding-left: 0pt;counter-reset: s2 1; }
 #l55> li>*:first-child:before {counter-increment: s2; content: counter(s2, lower-latin)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l55> li:first-child>*:first-child:before {counter-increment: s2 0;  }
 #l56 {padding-left: 0pt;counter-reset: s2 1; }
 #l56> li>*:first-child:before {counter-increment: s2; content: counter(s2, lower-latin)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l56> li:first-child>*:first-child:before {counter-increment: s2 0;  }
 #l57 {padding-left: 0pt;counter-reset: x1 1; }
 #l57> li>*:first-child:before {counter-increment: x1; content: counter(x1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l57> li:first-child>*:first-child:before {counter-increment: x1 0;  }
 #l58 {padding-left: 0pt;counter-reset: s2 1; }
 #l58> li>*:first-child:before {counter-increment: s2; content: counter(s2, lower-latin)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l58> li:first-child>*:first-child:before {counter-increment: s2 0;  }
 #l59 {padding-left: 0pt;counter-reset: s2 1; }
 #l59> li>*:first-child:before {counter-increment: s2; content: counter(s2, lower-latin)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l59> li:first-child>*:first-child:before {counter-increment: s2 0;  }
 #l60 {padding-left: 0pt;counter-reset: s2 1; }
 #l60> li>*:first-child:before {counter-increment: s2; content: counter(s2, lower-latin)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l60> li:first-child>*:first-child:before {counter-increment: s2 0;  }
 li {display: block; }
 #l61 {padding-left: 0pt;counter-reset: y1 1; }
 #l61> li>*:first-child:before {counter-increment: y1; content: counter(y1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l61> li:first-child>*:first-child:before {counter-increment: y1 0;  }
 #l62 {padding-left: 0pt;counter-reset: z1 1; }
 #l62> li>*:first-child:before {counter-increment: z1; content: counter(z1, lower-latin)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l62> li:first-child>*:first-child:before {counter-increment: z1 0;  }
 #l63 {padding-left: 0pt;counter-reset: y2 1; }
 #l63> li>*:first-child:before {counter-increment: y2; content: counter(y2, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l63> li:first-child>*:first-child:before {counter-increment: y2 0;  }
 #l64 {padding-left: 0pt;counter-reset: y2 1; }
 #l64> li>*:first-child:before {counter-increment: y2; content: counter(y2, decimal)". "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l64> li:first-child>*:first-child:before {counter-increment: y2 0;  }
 #l65 {padding-left: 0pt; }
 #l65> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l66 {padding-left: 0pt;counter-reset: d1 1; }
 #l66> li>*:first-child:before {counter-increment: d1; content: counter(d1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l66> li:first-child>*:first-child:before {counter-increment: d1 0;  }
 #l67 {padding-left: 0pt; }
 #l67> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l68 {padding-left: 0pt; }
 #l68> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l69 {padding-left: 0pt; }
 #l69> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l70 {padding-left: 0pt; }
 #l70> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l71 {padding-left: 0pt; }
 #l71> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l72 {padding-left: 0pt; }
 #l72> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l73 {padding-left: 0pt;counter-reset: e1 1; }
 #l73> li>*:first-child:before {counter-increment: e1; content: counter(e1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l73> li:first-child>*:first-child:before {counter-increment: e1 0;  }
 #l74 {padding-left: 0pt; }
 #l74> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l75 {padding-left: 0pt; }
 #l75> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l76 {padding-left: 0pt; }
 #l76> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l77 {padding-left: 0pt; }
 #l77> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l78 {padding-left: 0pt; }
 #l78> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l79 {padding-left: 0pt; }
 #l79> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l80 {padding-left: 0pt;counter-reset: f1 1; }
 #l80> li>*:first-child:before {counter-increment: f1; content: counter(f1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l80> li:first-child>*:first-child:before {counter-increment: f1 0;  }
 #l81 {padding-left: 0pt;counter-reset: g1 1; }
 #l81> li>*:first-child:before {counter-increment: g1; content: counter(g1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l81> li:first-child>*:first-child:before {counter-increment: g1 0;  }
 li {display: block; }
 #l82 {padding-left: 0pt;counter-reset: h1 1; }
 #l82> li>*:first-child:before {counter-increment: h1; content: counter(h1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l82> li:first-child>*:first-child:before {counter-increment: h1 0;  }
 #l83 {padding-left: 0pt; }
 #l83> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l84 {padding-left: 0pt; }
 #l84> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l85 {padding-left: 0pt; }
 #l85> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l86 {padding-left: 0pt; }
 #l86> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l87 {padding-left: 0pt;counter-reset: i1 1; }
 #l87> li>*:first-child:before {counter-increment: i1; content: counter(i1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l87> li:first-child>*:first-child:before {counter-increment: i1 0;  }
 #l88 {padding-left: 0pt; }
 #l88> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l89 {padding-left: 0pt; }
 #l89> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l90 {padding-left: 0pt; }
 #l90> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l91 {padding-left: 0pt; }
 #l91> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l92 {padding-left: 0pt; }
 #l92> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l93 {padding-left: 0pt; }
 #l93> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l94 {padding-left: 0pt;counter-reset: j1 1; }
 #l94> li>*:first-child:before {counter-increment: j1; content: counter(j1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l94> li:first-child>*:first-child:before {counter-increment: j1 0;  }
 #l95 {padding-left: 0pt; }
 #l95> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l96 {padding-left: 0pt; }
 #l96> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l97 {padding-left: 0pt; }
 #l97> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l98 {padding-left: 0pt; }
 #l98> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l99 {padding-left: 0pt;counter-reset: k1 1; }
 #l99> li>*:first-child:before {counter-increment: k1; content: counter(k1, lower-latin)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l99> li:first-child>*:first-child:before {counter-increment: k1 0;  }
 #l100 {padding-left: 0pt; }
 #l100> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l101 {padding-left: 0pt; }
 #l101> li>*:first-child:before {content: "- "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l102 {padding-left: 0pt; }
 #l102> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l103 {padding-left: 0pt; }
 #l103> li>*:first-child:before {content: "- "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l104 {padding-left: 0pt; }
 #l104> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l105 {padding-left: 0pt; }
 #l105> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l106 {padding-left: 0pt; }
 #l106> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l107 {padding-left: 0pt; }
 #l107> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l108 {padding-left: 0pt; }
 #l108> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l109 {padding-left: 0pt; }
 #l109> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l110 {padding-left: 0pt; }
 #l110> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 #l111 {padding-left: 0pt; }
 #l111> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; }
 li {display: block; }
 #l112 {padding-left: 0pt;counter-reset: m1 1; }
 #l112> li>*:first-child:before {counter-increment: m1; content: counter(m1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l112> li:first-child>*:first-child:before {counter-increment: m1 0;  }
 #l113 {padding-left: 0pt;counter-reset: m2 1; }
 #l113> li>*:first-child:before {counter-increment: m2; content: counter(m2, lower-latin)") "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l113> li:first-child>*:first-child:before {counter-increment: m2 0;  }
 li {display: block; }
 #l114 {padding-left: 0pt;counter-reset: n1 1; }
 #l114> li>*:first-child:before {counter-increment: n1; content: counter(n1, decimal)". "; color: black; font-family:Calibri, sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 14pt; }
 #l114> li:first-child>*:first-child:before {counter-increment: n1 0;  }
 #l115 {padding-left: 0pt; }
 #l115> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l116 {padding-left: 0pt; }
 #l116> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l117 {padding-left: 0pt; }
 #l117> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l118 {padding-left: 0pt; }
 #l118> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l119 {padding-left: 0pt; }
 #l119> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l120 {padding-left: 0pt; }
 #l120> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l121 {padding-left: 0pt; }
 #l121> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l122 {padding-left: 0pt; }
 #l122> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l123 {padding-left: 0pt; }
 #l123> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l124 {padding-left: 0pt; }
 #l124> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l125 {padding-left: 0pt; }
 #l125> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l126 {padding-left: 0pt; }
 #l126> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l127 {padding-left: 0pt; }
 #l127> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l128 {padding-left: 0pt; }
 #l128> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l129 {padding-left: 0pt; }
 #l129> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l130 {padding-left: 0pt; }
 #l130> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l131 {padding-left: 0pt; }
 #l131> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l132 {padding-left: 0pt; }
 #l132> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l133 {padding-left: 0pt; }
 #l133> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l134 {padding-left: 0pt; }
 #l134> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l135 {padding-left: 0pt; }
 #l135> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l136 {padding-left: 0pt; }
 #l136> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l137 {padding-left: 0pt; }
 #l137> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l138 {padding-left: 0pt; }
 #l138> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l139 {padding-left: 0pt; }
 #l139> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l140 {padding-left: 0pt; }
 #l140> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l141 {padding-left: 0pt; }
 #l141> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l142 {padding-left: 0pt; }
 #l142> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l143 {padding-left: 0pt; }
 #l143> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l144 {padding-left: 0pt; }
 #l144> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l145 {padding-left: 0pt; }
 #l145> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l146 {padding-left: 0pt; }
 #l146> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l147 {padding-left: 0pt; }
 #l147> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l148 {padding-left: 0pt; }
 #l148> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l149 {padding-left: 0pt; }
 #l149> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 #l150 {padding-left: 0pt; }
 #l150> li>*:first-child:before {content: " "; color: black; font-family:Symbol, serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 table, tbody {vertical-align: top; overflow: visible; }
</style></head><body><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Laboratorium 1</h1><p class="s1" style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Tabela – opisz jakie operacje można wykonać za pomocą komend ifconfig, ss, netstat, route, ip.</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;"><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="549" height="131" src="data:image/jpg;base64,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"/></td></tr><tr><td><img width="549" height="131" src="data:image/jpg;base64,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"/></td></tr></table></span></p><p class="s1" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">getsockopt(), setsockopt()</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Za pomocą tych funkcji możemy manipulować zarówno opcjami dotyczącymi ogólnego programu obsługi gniazd, jak i poszczególnych warstw protokołu w obrębie którego działa gniazdo. Zwracane wartości funkcji: 0 w przypadku powodzenia, -1 gdy błąd.</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">int setsockopt (int sockfd, int level, int optname, char *optval, int optlen) int getsockopt (int sockfd, int level, int optname, char *optval, int *optlen)</p><ul id="l1"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sockfd - deskryptor gniazda,</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">level - poziom, którego dotyczy opcja, możliwe wartości: SOL_SOCKET - najwyższy</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">poziom - ogólny program obsługi gniazd, IPPROTO_xxx - opcje protokołów,</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">optval - wskaźnik zmiennej użytkownika, z której pobierana jest wartość ustanawianej opcji (setsockopt) lub na którą zapisuje się wartość wybranej opcji (getsockopt),</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">optlen - rozmiar zmiennej wskazywanej przez optval.</p><p class="s1" style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">SO_KEEPALIVE</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Wysyłanie tzw. pakietów keep-alive wł/wył (0/1). Pakiety te pełnią rolę diagnostyczną - badają, czy zdalna maszyna jest w stanie obsługiwać nasze połączenie. Tylko gniazda połączeniowe. Trzeba pamiętać, że standardowo odstęp czasowy między tymi pakietami wynosi 2h (7200s).</p><p class="s1" style="padding-top: 10pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">SO_RCVBUF/ SO_SNDBUF</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Ustawia lub pobiera maksymalny rozmiar bufora odbiorczego/nadawczego.</p><p class="s1" style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">SO_BINDTODEVICE</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Związuje gniazdo z konkretnym interfejsem sieciowym. Wartość dla tej opcji to nazwa interfejsu (np. <i>eth0</i>). Takie gniazdo będzie otrzymywało tylko pakiety odebrane poprzez wskazany interfejs.</p><p class="s1" style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">SO_REUSEADDR</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Normalnie funkcja bind() zwraca błąd jeśli spróbujemy związać gniazdo z adresem, który jest aktualnie w użyciu. Jeśli chcielibyśmy z tym adresem skojarzyć jakieś inne gniazdo nie czekając na zakończenie procesu zamykania połączenia to musimy włączyć właśnie tą opcję.</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Nawet SO_REUSEADDR nie pomoże jeśli gniazdo nasłuchuje (LISTEN) na danym adresie.</p><p class="s1" style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">SO_LINGER</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Steruje zachowaniem funkcji close() dla TCP. Argumentem tej opcji jest struktura:</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">struct linger{</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">int l_onoff; /* opcja SO_LINGER wł/wył */</p><p style="padding-left: 47pt;text-indent: 0pt;line-height: 15pt;text-align: left;">int l_linger; /* limit czasowy na wysłanie danych */</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">};</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Jeśli l_onoff jest równe 0 to wspomniane funkcje działają standardowo tzn. natychmiast zwracają sterowanie, a wszystkie pakiety znajdujące się w kolejce wysłania są obsługiwane niezależnie przez jądro.</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Jeśli natomiast l_onoff jest różne od zera to wywołania close() oraz shutdown()</p></li><li data-list-text=""><p style="padding-top: 9pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">jeśli l_linger jest różne od zera to proces będzie uśpiony dopóki zostaną wysłane wszystkie pakiety przy czym l_linger określa maksymalny czas uśpienia (w tym przypadku celowe jest sprawdzanie kodu powrotu z funkcji close())</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">jeśli l_linger jest równe zero to wszystkie pakiet znajdujące się w kolejce wysyłkowej zostaną zniszczone oraz nastąpi natychmiastowe zerwanie połączenia poprzez wysłanie segmentu RST (gniazdo nie przechodzi przez stan TIME_WAIT, tylko do stanu CLOSED).</p></li></ul><p class="s1" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">SO_DEBUG</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">Włącza/wyłącza diagnostykę prowadzona na niższych warstwach protokołów (polega ona na utrzymywaniu przez jadro historii ostatnio wysłanych i odebranych pakietów).</p><p class="s1" style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">SO_DONTROUTE</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Pakiet przeznaczony dla sieci lokalnej</p><p class="s1" style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">SO_OOBINLINE</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Jeśli opcja włączona, to dane typu out-of-band będą wymieszane razem z danymi właściwymi w strumieniu wejściowym. Oznacza to, ze dane OOB będą odbierane przy każdym wywołaniu recv(). Jeśli opcja ta będzie wyłączona (domyślnie) to OOB będzie odbierane tylko w przypadku dołączenia flagi MSG_OOB w wywołaniu recv().</p><p class="s1" style="padding-top: 10pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">SO_RCVLOWAT/SO_SNDLOWAT</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Znaczniki dla funkcji <i>select() </i>i <i>pool() </i>dolnego ograniczenia dla buforów odbiorczego/nadawczego</p><p class="s1" style="padding-top: 10pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">IP_TOS</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Ustawia/pobiera pole TOS (TypeOf Service) w nagłówku IP.</p><p class="s1" style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">IP_MTU</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Pobiera aktualną wartość MTU (Maximum Transmit Unit) używaną przez dane gniazdo.</p><p class="s1" style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">IP_TTL</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Ustawia/pobiera pole TTL (Time To Live) nagłówka IP.</p><p class="s1" style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">IPV6_UNICAST_HOPS</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Analogiczna opcja do IP_TTL</p><p class="s1" style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">IPV6_MTU</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Pobieranie/ustawianie MTU</p><p class="s1" style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">IPV6_MTU_DISCOVER</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Sterowanie wykrywaniem MTU na ścieżce</p><p class="s1" style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">IPV6_DONTFRAG</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Wskazuje, że dany pakiet nie powinien podlegać fragmentacji</p><p class="s1" style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">IPV6_V6ONLY</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">Gdy ustawione na TRUE umożliwia wysyłanie tylko pakietów IPv6, więc może przypisać do portu równocześnie aplikacje IPv6 i IPv4</p><p class="s1" style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">TCP_MAXSEG</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Maksymalny rozmiar segmentu TCP. Nie może być większe niż MTU (Maximal Transmission Unit) interfejsu, przez który będą wysłane segmenty.</p><p class="s1" style="padding-top: 10pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">TCP_NODELAY</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Jeśli równe 1 to zostaje wyłączony tzw. algorytm Nagle. Algorytm ten wstrzymuje transmisję segmentów TCP dopóki nie zostanie uzbierana wystarczająca paczka danych. Włączenie tej opcji jest uzasadnione jeśli zależy nam na wysyłaniu małych porcji danych bez zbędnych opóźnień.</p><p class="s1" style="padding-top: 10pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">TCP_KEEPALIVE</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Działa tylko jeśli włączona opcja SO_KEEPALIVE</p><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Pytania - wejściówka 1</h1><ol id="l2"><li data-list-text="1."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Opisz opcje gniazd: TCP_NODELAY, IP_TTL</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">TCP_NODELAY: Jeśli równe 1 to zostaje wyłączony tzw. algorytm Nagle, który wstrzymuje transmisję segmentów TCP dopóki nie zostanie uzbierana wystarczająca paczka danych.</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">IP_TTL: ustawia/pobiera TTL w nagłówku IP</p></li><li data-list-text="2."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">W protokole TCP, która strona połączenia serwer-klient przechodzi przez stan TIME_WAIT</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Przez stan TIME_WAIT przechodzi ta strona komunikacji, która rozpoczęła aktywne zakończenie połączenia. Może to być zarówno klient, jak i serwer.</p></li><li data-list-text="3."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">W protokole TCP, która strona połączenia serwer-klient przechodzi przez stan ESTABLISHED</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 14pt;text-align: left;">Zarówno klient jak i serwer.</p></li><li data-list-text="4."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">W protokole TCP, która strona połączenia serwer-klient przechodzi przez stan CLOSE_WAIT</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Strona, która wykonuje pasywne zamknięcie połączenia (może to być i klient i serwer) - po otrzymaniu segmentu FIN</p></li><li data-list-text="5."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie parametry definiują jednoznacznie połączenie pomiędzy dwoma</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">procesami w sieci TCP/IP</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Adres i port lokalny, adres i port zdalny, protokół transportowy</p></li><li data-list-text="6."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jak zamknąć sesję TCP segmentem RESET?</p></li></ol><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Poprzez ustawienie opcji SO_LINGER. Jeśli l_onoff jest różne od zera oraz jeśli l_linger jest równe zero to wszystkie pakiet znajdujące się w kolejce wysyłkowej zostaną zniszczone oraz nastąpi natychmiastowe zerwanie połączenia poprzez wysłanie segmentu RST (gniazdo nie przechodzi przez stan TIME_WAIT, tylko przechodzi do stanu CLOSED).</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Lub innymi słowy:</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">należy ustawić opcję so_linger w taki sposób:</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">struct linger {</p><p style="padding-top: 1pt;padding-left: 47pt;text-indent: 0pt;line-height: 111%;text-align: left;">int l_onoff = 1; int l_linger = 0;</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">a następnie wywołać funkcję close()</p><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Laboratorium 2</h1><ol id="l3"><li data-list-text="1."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Zestawianie sesji TCP. Opisz uzgadnianie trójfazowe dla protokołu TCP.</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Uzgadnianie trójfazowe (three way handshake)</p><ol id="l4"><li data-list-text="1."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Otwarcie pasywne (Serwer: socket(), bind(), listen())</p></li><li data-list-text="2."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Otwarcie aktywne - Klient: connect() - wysyła SYN J</p></li><li data-list-text="3."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Serwer wysyła potwierdzenie SYN J (ACK J+1) i SYN K</p></li><li data-list-text="4."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Klient wysyła potwierdzenie SYN K (ACK K+1)</p></li></ol></li><li data-list-text="2."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Zamykanie sesji TCP</p><ol id="l5"><li data-list-text="1."><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Pierwszy punkt końcowy (klient lub serwer) wywołuje funkcję close() - zamknięcie</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">aktywne - wysyłany segment FIN</p></li><li data-list-text="2."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Drugi punkt końcowy odbiera FIN, wykonuje zamknięcie bierne, potwierdza FIN</p></li><li data-list-text="3."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Drugi punkt końcowy wywołuje close() i TCP wysyła FIN</p></li><li data-list-text="4."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Pierwszy punkt końcowy wysyła potwierdzenie</p></li></ol></li><li data-list-text="3."><p class="s1" style="padding-top: 2pt;padding-bottom: 1pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Stany protokołu TCP</p><table style="border-collapse:collapse;margin-left:5.825pt" cellspacing="0"><tr style="height:14pt"><td style="width:100pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666"><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;">Serwer</p></td><td style="width:365pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666"><p class="s3" style="padding-left: 9pt;text-indent: 0pt;line-height: 12pt;text-align: left;">LISTEN - Gotowość do przyjęcia połączenia na określonym porcie przez serwer.</p></td></tr><tr style="height:28pt"><td style="width:100pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666" bgcolor="#CCCCCC"><p class="s3" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Klient</p></td><td style="width:365pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666" bgcolor="#CCCCCC"><p class="s3" style="padding-left: 9pt;padding-right: 6pt;text-indent: 0pt;line-height: 14pt;text-align: left;">SYN-SENT - Pierwsza faza nawiązywania połączenia przez klienta. Wysłano pakiet z flagą SYN. Oczekiwanie na pakiet SYN+ACK.</p></td></tr><tr style="height:28pt"><td style="width:100pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666"><p class="s3" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Serwer</p></td><td style="width:365pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666"><p class="s3" style="padding-left: 9pt;padding-right: 6pt;text-indent: 0pt;line-height: 14pt;text-align: left;">SYN-RECEIVED - Otrzymano pakiet SYN, wysłano SYN+ACK. Trwa oczekiwanie na ACK. Połączenie jest w połowie otwarte (ang. half-open).</p></td></tr><tr style="height:28pt"><td style="width:100pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666" bgcolor="#CCCCCC"><p class="s3" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Oba</p></td><td style="width:365pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666" bgcolor="#CCCCCC"><p class="s3" style="padding-left: 9pt;text-indent: 0pt;line-height: 14pt;text-align: left;">ESTABLISHED - Połączenie zostało prawidłowo nawiązane. Prawdopodobnie trwa transmisja.</p></td></tr><tr style="height:28pt"><td style="width:100pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666"><p class="s3" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Strona zamykająca</p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 13pt;text-align: left;">aktywnie</p></td><td style="width:365pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666"><p class="s3" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">FIN-WAIT-1 - Wysłano pakiet FIN. Dane wciąż mogą być odbierane ale</p><p class="s3" style="padding-left: 9pt;text-indent: 0pt;line-height: 13pt;text-align: left;">wysyłanie jest już niemożliwe.</p></td></tr><tr style="height:28pt"><td style="width:100pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666" bgcolor="#CCCCCC"><p class="s3" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Strona zamykająca</p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;">pasywnie</p></td><td style="width:365pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666" bgcolor="#CCCCCC"><p class="s3" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">CLOSE-WAIT - Otrzymano pakiet FIN, wysłano ACK. Oczekiwanie na przesłanie</p><p class="s3" style="padding-left: 9pt;text-indent: 0pt;line-height: 12pt;text-align: left;">własnego pakietu FIN (gdy aplikacja skończy nadawanie).</p></td></tr><tr style="height:42pt"><td style="width:100pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666"><p class="s3" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Strona zamykająca</p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">aktywnie</p></td><td style="width:365pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666"><p class="s3" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">FIN-WAIT-2 - Otrzymano potwierdzenie własnego pakietu FIN. Oczekuje na przesłanie FIN od drugiej strony.</p></td></tr><tr style="height:28pt"><td style="width:100pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666" bgcolor="#CCCCCC"><p class="s3" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Strona zamykająca</p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;">pasywnie</p></td><td style="width:365pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666" bgcolor="#CCCCCC"><p class="s3" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">LAST-ACK - Otrzymano i wysłano FIN. Trwa oczekiwanie na ostatni pakiet ACK.</p></td></tr><tr style="height:28pt"><td style="width:100pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666"><p class="s3" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Strona zamykająca</p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 12pt;text-align: left;">aktywnie</p></td><td style="width:365pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666"><p class="s3" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">TIME-WAIT - Oczekiwanie w celu upewnienia się, że druga strona otrzymała</p><p class="s3" style="padding-left: 9pt;text-indent: 0pt;line-height: 12pt;text-align: left;">potwierdzenie rozłączenia.</p></td></tr><tr style="height:28pt"><td style="width:100pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666" bgcolor="#CCCCCC"><p class="s3" style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Strona zamykająca</p><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 13pt;text-align: left;">aktywnie</p></td><td style="width:365pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666" bgcolor="#CCCCCC"><p class="s3" style="padding-left: 9pt;text-indent: 0pt;text-align: left;">CLOSING - Połączenie jest zamykane.</p></td></tr><tr style="height:14pt"><td style="width:100pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666"><p class="s3" style="padding-left: 6pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Oba</p></td><td style="width:365pt;border-top-style:solid;border-top-width:1pt;border-top-color:#666666;border-bottom-style:solid;border-bottom-width:1pt;border-bottom-color:#666666"><p class="s3" style="padding-left: 9pt;text-indent: 0pt;line-height: 13pt;text-align: left;">CLOSED - Połączenie jest zamknięte.</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="4."><p class="s1" style="padding-left: 29pt;text-indent: -18pt;text-align: left;">Kiedy powstaje stan TIME-WAIT w sesji TCP i jakie ma znaczenie?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">TIME_WAIT - punkt końcowy, który wykonuje aktywne zakończenie przechodzi przez ten stan</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">Służy do poprawnego zakończenia połączenia i zminimalizowania prawdopodobieństwa, że nowe połączenie otrzyma zagubione datagramy z wcześniejszego połączenia</p></li><li data-list-text="5."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Na jakie główne parametry połączenia może mieć wpływ zastosowana</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">warstwa transportowa w aplikacji sieciowej?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">Na opóźnienie, szybkość transmisji, straty pakietów, kolejność pakietów w UDP może być rożna, Istnienie retransmisji</p></li><li data-list-text="6."><p class="s1" style="padding-top: 9pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakiego typu adresowanie wspierają protokoły transportowe TCP, UDP i</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">SCTP?</p><ul id="l6"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">UDP - unicast, multicast, broadcast</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">TCP - unicast</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">SCTP - unicast</p></li></ul></li><li data-list-text="7."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie parametry określają adres aplikacji w sieci IP?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Adres IP, maska, port, protokół transportowy</p></li><li data-list-text="8."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Różnice w działaniu serwerów iteracyjnych i współbieżnych</p></li></ol><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Serwer iteracyjny – klienci obsługiwani w kolejności zgłoszeń</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Serwer współbieżny – klienci obsługiwani w tym samym czasie przez zbiór procesów, z użyciem wątków lub multipleksacji gniazd</p><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Laboratorium 3</h1><ol id="l7"><li data-list-text="1."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jaka jest sieciowa kolejność bajtów?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Kolejność big-endian, z pierwszeństwem bajtu bardziej znaczącego</p></li><li data-list-text="2."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Kiedy do procesu jest wysyłany sygnał SIGCHILD?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Kiedy proces DZIECKA kończy swoje działanie, do procesu RODZICA jest wysyłany sygnał SIGCHILD. Domyślnie jest ignorowany. Sygnał może być przechwycony, a status wyjścia z procesu potomnego można uzyskać poprzez wywołanie waitpid() lub wait(). Pozwala to na jak najszybsze usunięcie procesów zombie.</p></li><li data-list-text="3."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Kiedy do procesu jest wysyłany sygnał SIGPIPE?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Do procesu klienta wysyłany, gdy gniazdo połączone TCP otrzymało segment RST, a proces klienta wywoła funkcję piszącą do gniazda.</p></li><li data-list-text="4."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Kiedy do procesu jest wysyłany sygnał SIGURG?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Wysyłany jest do odbiorcy danych out-of-band, aby został wysłany musi być ustawiona flaga MSG_OOB w funkcji wysyłającej. Domyślnie nie jest dostarczany, bez obsługi ten sygnał jest ignorowany.</p></li><li data-list-text="5."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do czego służy funkcja waitpid()?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Pozwala określić na jakie procesy potomne ma czekać program rodzic, pozwala uniknąć</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">powstawania procesów zombie</p></li><li data-list-text="6."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do czego służy funkcja sigaction()?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">Służy do przechwytywania sygnałów i umożliwia ustawienie w jaki sposób będzie obsługiwany dany sygnał</p></li><li data-list-text="7."><p class="s1" style="padding-top: 9pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do czego służy flaga SA_RESTART?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Flaga do otrzymania sygnałów restartujących (w przypadku przerwania działania funkcji systemowej przez sygnał z ustawiona flaga funkcja ta jest ponawiana)</p></li><li data-list-text="8."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">W jaki sposób zakończyć natychmiast połączenie TCP (nie zresetować)?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">W celu natychmiastowego zerwania połączenia wywołuje się funkcję shutdown(), która wysyła</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">segment FIN</p></li><li data-list-text="9."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Kiedy wywołanie funkcji close() na gnieździe połączonym spowoduje wysłanie segmentu FIN dla połączenia TCP, a kiedy nie?</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Żeby segment FIN został wysłany, licznik odniesień do gniazda musi wynosić 0</p></li><li data-list-text="10."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Kiedy dla gniazda blokującego TCP/UDP funkcja czytająca z gniazda zwraca wartość 0?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Jeżeli czytanie przesłanego pakietu zaczyna się na jego końcu (jest pusty)</p></li><li data-list-text="11."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Kiedy dla gniazda blokującego TCP/UDP funkcja czytająca z gniazda zwraca wartość -1?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Jeżeli wystąpi błąd.</p></li><li data-list-text="12."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Kiedy dla gniazda blokującego TCP/UDP funkcja czytająca z gniazda zwraca wartość większą od zera?</p><p class="s4" style="padding-left: 11pt;text-indent: 0pt;line-height: 13pt;text-align: left;">Jeśli odczytane zostaną dane, zwróconą wartością będzie liczba odczytanych bajtów.</p></li><li data-list-text="13."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Kiedy dla gniazda nieblokującego funkcja czytająca z gniazda zwraca wartość -1?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Jeżeli wystąpi błąd.</p></li><li data-list-text="14."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Czym różnią się funkcja write() od send() i sendto()? Jaka jest różnica pomiędzy funkcjami send() i write() przy pisaniu do gniazd sieciowych?</p><ul id="l8"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Funkcje write() i send() działają tylko w połączeniu z funkcją connect()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Dla funkcji write() nie mamy możliwości ustawić flagi.</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Dla funkcji send() możemy ustawić dodatkowe flagi</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Funkcja sendto() od funkcji send() różni się tym że ma dwa dodatkowe parametry, przez które możemy przekazać adres do kogo dany pakiet powinien być wysyłany</p></li></ul></li><li data-list-text="15."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 110%;text-align: left;">Czym różni się funkcja read() od recv() i recvfrom()? Jaka jest różnica pomiędzy funkcjami recv() i read() przy czytaniu z gniazd sieciowych?</p><ul id="l9"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Dla funkcji read() nie mamy możliwości ustawić flagi.</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Dla funkcji recv() możemy ustawić dodatkowe flagi</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Funkcja recvfrom() od funkcji recv() różni się tym że ma dwa dodatkowe parametry:</p><ul id="l10"><li data-list-text="o"><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">wskaźnik pod, którym zostanie zapisany adres nadawcy danych</p></li><li data-list-text="o"><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">długość tego adresu</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">(może być użyta dla TCP, ale musi mieć oba te wskaźniki ustawione na 0)</p></li></ul></li></ul></li><li data-list-text="16."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Do czego służą i jakie parametry posiadają funkcje: socket(), connect(), bind(), listen(), accept(), close(), shutdown(), getsockname(), getpeername()?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">int socket( int domain, int type, int protocol); tworzy gniazdo</p><p style="padding-top: 7pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: justify;">Argumenty: domain (tzw. Domena adresowa), type (sposób komunikacji np. dwukierunkowa, bezpołączeniowa itp.), protocol (określa protokół z którego będziemy korzystać). Zwraca -1 w przypadku błędu albo deskryptor gniazda (ważne do obsługi gniazd).</p><p style="padding-top: 10pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">int bind(int sockfd, const struct sockaddr*, socklen_t addrlen);</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">dowiązanie do konkretnego adresu lub zbioru adresów i portu</p><p style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">int listen(int s, int backlog);</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">mówimy systemowi, że od tej pory może zestawiać dla naszego procesu połączenie</p><p style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">Argumenty: s (deskryptor gniazda), backlog (maksymalna ilość połączeń, które mogą jednocześnie oczekiwać na obsłużenie przez serwer –nadmiar będzie odrzucany).</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 14pt;text-align: left;">Standardowo zwraca 0 lub -1 (w przypadku błędu).</p><p style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">int connect(int sockfd, struct sockaddr *serv_addr, int addrlen);</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">łączenie się ze zdalnym procesem serwera.</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Argumenty: sockfd (deskryptor gniazda), serv_addr (wskaźnik do gniazdowej struktury</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">adresowej opisującej proces serwera). Zwraca -1 gdy błąd oraz 0 w przypadku powodzenia.</p><p style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">int accept(int s, struct sockaddr *addr, int *addrlen);</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">odbiera połączenie z gniazda</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Argumenty: s (deskryptor gniazda), addr (pusta struktura która zostanie przez funkcję uzupełniona), addrlen (wielkość struktury). Funkcja zwraca deskryptor nowo utworzonego gniazda (lub -1 w przypadku błędu).</p><p style="padding-top: 10pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">int send( int s, const void *msg, int len, unsigned int flags);</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">wysyłanie danych</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Argumenty: s (deskryptor), msg (wskaźnik do bufora, który chcemy wysłać), len (długośćbufora), flags (flagi). Zwraca ilość wysłanych bajtów bądź -1 w przypadku błędu</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">int recv( int s, void *buf, int len, unsigned int flags); odbieranie danych,</p><p style="padding-top: 7pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Argumenty: s (deskryptor), buf (wskaźnik do bufora w którym odebrane dane zostaną umieszczone), len (długość wektora), flags (flaga). Funkcja zwraca ilość odebranych danych lub -1 w przypadku błędu.</p><p style="padding-top: 10pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">int getsockname( int s, struct sockaddr *name, socklen_t *namelen);</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">zwraca nazwę gniazda lokalnego</p><p style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">int getpeername( int s, struct sockaddr *name, socklen_t *namelen);</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">zwraca nazwę gniazda zdalnego.</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Argumenty: s (deskryptor), name (wskaźnik do bufora gdzie wpisać imię), namelen (długość</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">podanego bufora). Zwraca 0 w przypadku sukcesu oraz -1 w przypadku błędu.</p><p style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">int close( int fd);</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">zamykanie zainicjalizowanego połączenia</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 26pt;text-align: left;">Argument fd (deskryptor gniazda). Zamyka kiedy licznik odniesień jest równy 1. int shutdown( int s, int how);</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">Natychmiastowe zerwanie połączenia, może zamknąć gniazdo niezależnie od licznika odniesień do gniazda</p><p style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">Argumenty: s (deskryptor gniazda), how (0 – odbieranie danych nie będzie możliwe, 1 –wysyłanie nie będzie możliwe, 2 – nic nie będzie możliwe). shutdown(s,2) zamyka zawsze.</p></li><li data-list-text="17."><p class="s1" style="padding-top: 9pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Co to są funkcje reentrant?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Funkcje wielowejściowe, które mogą być bezpiecznie wywoływane jednocześnie w procesie i w procedurze obsługi sygnałów. Nie korzystają ze zmiennych globalnych/statycznych.</p></li><li data-list-text="18."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Czym wyróżnia się funkcja recvfrom()?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Pozwala aplikacji uzyskać adres nadawcy danych.</p></li><li data-list-text="19."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie flagi obsługują funkcje recv() i recvfrom()? Czym różnią się od funkcji</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">read()?</p><ul id="l11"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">MSG_DONTWAIT – ta flaga sprawia ze wywołana funkcja jest nieblokowalna</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">MSG_WAITALL – czytanie wszystkich danych, zgodnie z wartością parametru count</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">MSG_OOB – żądanie otrzymania danych poza pasmowych(tylko TCP)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">MSG_PEEK – podgląd nadchodzącego komunikatu</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: justify;">MSG_TRUNC – informowanie, że dane zostały obcięte z powodu zbyt małego bufora odbiorczego – funkcja zwraca liczbę faktycznie odebranych danych przez gniazdo a nie liczbę danych skopiowanych do bufora odbiorczego</p></li></ul></li><li data-list-text="20."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: justify;">Jakie flagi obsługują funkcje send() i sendto()? Czym różnią się od funkcji</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">write()?</p><ul id="l12"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">MSG_DONTWAIT – ta flaga sprawia ze wywołana funkcja jest nieblokowalna</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">MSG_DONTROUTE – pakiet przeznaczony dla sieci lokalnej</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">MSG_OOB – dane poza pasmowe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">MSG_CONFIRM – dla gniazd DGRAM i RAW, wymuszenie uaktualniania odwzorowania adresów IP&lt;-&gt;MAC</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">MSG_MORE–(LINUX) – jeśli ta flaga jest uaktywniona dane wysyłane do gniazda są</p></li></ul></li></ol><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">gromadzone, a nie wysyłane. Wysłanie następuje po wyłączeniu tej fagi.</p><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Pytania - wejściówka 2</h1><ol id="l13"><li data-list-text="1."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Co oznacza flaga MSG_DONTWAIT w funkcji recv()?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Oznacza że operacja jest nieblokowana, czyli nie ma potrzeby ustawiania opcji gniazda</p></li><li data-list-text="2."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Co oznacza flaga MSG_PEEK w funkcji recv()?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Oznacza podgląd nadchodzącego następnego komunikatu.</p></li><li data-list-text="3."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Co oznacza flaga MSG_OOB w funkcji recv()?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Otrzymania danych poza pasmowych</p></li><li data-list-text="4."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Funkcji recv() jaką funkcję spełnia flaga MSG_WAITALL?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Wymusza czekanie dopóki nie zostaną otrzymane wszystkie wiadomości.</p></li><li data-list-text="5."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz w jaki sposób sprawdzić, czy przy zadanym parametrze IP_TTL będzie można uzyskać połączenie z serwerem:</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">TTL określa przez ile routerów maksymalnie może przejść pakiet. Po przejściu przez router ta wartość jest redukowana o 1, aż dojdzie do 0, w tym momencie pakiet jest odrzucany.</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Dodatkowo należy użyć ping lub traceroute aby dostać informację o liczbie węzłów pośrednich.</p></li><li data-list-text="6."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Czym różni się funkcja ntohs() i ntohl()? Do czego służą te funkcje?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Funkcje konwertują liczby między hostami i siecią. nthos() do danych netshort, ntohl() do danych netlong. W sieci kolejność bajtów to big-endian (MSB first), a hostów little-endian.</p></li><li data-list-text="7."><p class="s1" style="padding-top: 9pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Czym różni się funkcja htons() i htonl()? Do czego służą te funkcje?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">htonl() przekształca wartośc long integer (32 bity) hostlong na sieciowy porządek bajtów. htons () przekształca wartość short integer (16 bity) hostshort na sieciowy porządek bajtów</p><p class="s1" style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Ad. 8 – 11: Na serwerze o adresie IPv6 =2001:6d8:10:3410:215:17ff:fe41:d388 i IPv4=149.156.203.6 uruchomiono program serwera iteracyjnego XYSERV, który utworzył gniazdo strumieniowe (ważna kolejność wywoływanych funkcji (AF_INET6, SOCK_STREAM, 0)). Serwer początkowo nasłuchuje na adresie ustawionym za pomocą stałej in6addr_any i porcie 51.</p></li><li data-list-text="8."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Opcję gniazda IPV6_V6ONLY ustawione na false oraz opcję SO_REUSEADDR</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">na true.</p><ol id="l14"><li data-list-text="a."><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Możliwe jest uruchomienie innego procesu serwera, który będzie akceptował połączenia na adresie IPv4 149.156.203.6 i porcie 51, gdy w procesie XYSERV gniazdo jest w stanie LISTEN</p></li><li data-list-text="b."><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Inny proces może dowiązać się do tego gniazda tylko wtedy, gdy proces XYSERV</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">zamknął to gniazdo.</p></li><li data-list-text="c."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Możliwe jest uruchomienie innego procesu serwera, który będzie akceptował połączenia na adresie IPv4 127.0.0.1 i porcie 51, gdy w procesie XYSERV pozostało tylko gniazdo w stanie LISTEN</p></li><li data-list-text="d."><p class="s5" style="padding-top: 4pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Inny proces może dowiązać port 51 do gniazda, gdy w procesie XYSERV gniazdo jest w</p><p class="s5" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">stanie TIME_WAIT. .0.0.1</p></li><li data-list-text="e."><p class="s5" style="padding-left: 47pt;text-indent: -18pt;line-height: 111%;text-align: left;">Możliwe jest uruchomienie innego procesu serwera, który będzie akceptował połączenia na adresie IPv4 127.0.0.1 i porcie 51, gdy w procesie XYSERV pozostało tylko gniazdo w stanie ESTABLISHED.</p></li></ol></li><li data-list-text="9."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Opcję gniazda IPV6_V6ONLY ustawiono na true oraz opcję SO_REUSEADDR</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">na true.</p><ol id="l15"><li data-list-text="a."><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Nie jest możliwe uruchomienie innego procesu serwera, który będzie akceptował połączenia na adresie IPv4 127.0.0.1 i porcie 51, gdy w procesie XYSERV pozostało tylko gniazdo w stanie LISTEN.</p></li><li data-list-text="b."><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Inny proces może dowiązać port 51 do gniazda, tylko wtedy gdy w procesie XYSERV</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">gniazdo jest w stanie ESTABLISHED.</p></li><li data-list-text="c."><p class="s5" style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Inny proces może zawsze dowiązać się do gniazda na adresie 127.0.0.1 i porcie 51, gdyż opcja IPV6_V6ONLY=true na to pozwala.</p></li><li data-list-text="d."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Możliwe jest uruchomienie innego procesu serwera, który będzie akceptował połączenia na adresie IPv4 149.156.203.6 i porcie 51, gdyż opcja SO_REUSEADDR=true pozwala na wielokrotne użycie gniazda przez wiele procesów.</p></li><li data-list-text="e."><p class="s5" style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Możliwe jest uruchomienie innego procesu serwera, który będzie akceptował połączenia na adresie IPv4 149.156.203.6 i porcie 51</p></li></ol></li><li data-list-text="10."><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Opcję gniazda IPV6_V6ONLY ustawiono na true oraz opcję SO_REUSEADDR</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">na false.</p><ol id="l16"><li data-list-text="a."><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Inny proces nie może dowiązać portu 51 do gniazda, gdy w procesie XYSERV gniazdo</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">jest w stanie TIME_WAIT.</p></li><li data-list-text="b."><p class="s5" style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Możliwe jest uruchomienie innego procesu serwera, który będzie akceptował połączenia na adresie IPv4 127.0.0.1 i porcie 51, gdy w procesie XYSERV pozostało tylko gniazdo w stanie LISTEN.</p></li><li data-list-text="c."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Inny proces może dowiązać się do tego gniazda tylko wtedy, gdy proces XYSERV zamknął to gniazdo.</p></li><li data-list-text="d."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Możliwe jest uruchomienie innego procesu serwera, który będzie akceptował połączenia na adresie IPv6 ::1 i porcie 51, gdy w procesie XYSERV gniazdo jest w stanie TIME_WAIT</p></li></ol></li><li data-list-text="11."><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opcję gniazda IPV6_V6ONLY ustawiono na false oraz opcję SO_REUSEADDR na wartość domyślną.</p><ol id="l17"><li data-list-text="a."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Możliwe jest uruchomienie innego procesu serwera, który będzie akceptował połączenia na adresie IPv4 149.156.203.6 i porcie 51, gdyż opcja SO_REUSEADDR=false pozwala na wielokrotne użycie gniazda przez wiele procesów.</p></li><li data-list-text="b."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Możliwe jest uruchomienie innego procesu serwera, który będzie akceptował połączenia na adresie IPv4 127.0.0.1 i porcie 51, gdy w procesie XYSERV pozostało tylko gniazdo w stanie LISTEN.</p></li><li data-list-text="c."><p class="s5" style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Nie jest możliwe jest uruchomienie innego procesu serwera, który będzie akceptował połączenia na adresie IPv4 149.156.203.6 i porcie 51</p></li><li data-list-text="d."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Inny proces może dowiązać port 51 do gniazda, gdy w procesie XYSERV gniazdo jest w</p></li></ol></li></ol><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">stanie TIME_WAIT.</p><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Laboratorium 4</h1><ol id="l18"><li data-list-text="1."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jaka jest domyślna reakcja procesu na otrzymanie sygnałów (gdy w programie nie są przechwytywane sygnały) SIGCHILD, SIGPIPE, SIGURG</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">SIGCHILD – zignorowanie SHIPIPE – zakończenie procesu SIGURG – zignorowanie</p></li><li data-list-text="2."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do czego służą flagi SOCK_NONBLOCK i SOCK_CLOEXEC w funkcjach</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">socket() i accept()</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">SOCK_NONBLCOK - zmienia gniazdo w gniazdo nieblokujące</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">SOCK_CLOEXEC - zamyka deskryptor gniazda w przypadku wywołania funkcji exec()</p></li><li data-list-text="3."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do czego służy funkcja connect() dla protokołu UDP?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Przy wysyłaniu datagramów nie musimy podawać adresu (read(), writer() ). Dla UDP określa, że pakiety będą wysyłane i dobierane tylko dla danego adresu</p></li><li data-list-text="4."><p class="s1" style="padding-top: 9pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do czego służy funkcja listen() dla protokołu UDP?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">UDP nie wspiera listen()</p></li><li data-list-text="5."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Kiedy proces może odbierać błędy asynchroniczne ICMP na gnieździe UDP?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Ustawienie opcji gniazda SO_ERROR.</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Gdy gniazdo jest połączone funkcją connect() - umożliwia ona otrzymywanie błędów</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">asynchronicznych przez gniazdo.</p></li><li data-list-text="6."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie funkcje sieciowe należy wywołać po stronie serwera, aby można było odebrać pakiet od klienta:</p><ol id="l19"><li data-list-text="a)"><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">dla protokołu TCP?</p><ul id="l20"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 83pt;text-indent: -18pt;text-align: left;">socket()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">listen()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">accept()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">read()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">…</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">read() – odczytujemy znacznik końca pliku</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">close()</p></li></ul></li><li data-list-text="b)"><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">dla protokołu UDP?</p><ul id="l21"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 83pt;text-indent: -18pt;text-align: left;">socket()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">rcvfrom()</p></li></ul></li></ol></li><li data-list-text="8."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie funkcje należy wywołać po stronie serwera, aby można było wysłać</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">pakiet do klienta:</p><ol id="l22"><li data-list-text="a)"><p style="padding-top: 3pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">dla protokołu TCP?</p><ul id="l23"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 83pt;text-indent: -18pt;text-align: left;">socket()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">bind()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">listen()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">write()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">…</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">read() – odczytujemy znacznik końca pliku</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">close()</p></li></ul></li><li data-list-text="b)"><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">dla protokołu UDP?</p><ul id="l24"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 83pt;text-indent: -18pt;text-align: left;">socket()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">bind()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">sendto()</p></li></ul></li></ol></li><li data-list-text="9."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie funkcje sieciowe należy wywołać po stronie klienta, aby można było odebrać pakiet od serwera:</p><ol id="l25"><li data-list-text="a)"><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">dla protokołu TCP?</p><ul id="l26"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">connect()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">read()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">…</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">close()</p><ol id="l27"><li data-list-text="c)"><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">dla protokołu UDP?</p><ul id="l28"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvfrom()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">…</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">close()</p></li></ul></li></ol></li></ul></li></ol></li><li data-list-text="10."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie funkcje sieciowe należy wywołać po stronie klienta, aby można było wysłać pakiet do serwera:</p><ol id="l29"><li data-list-text="a)"><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">dla protokołu TCP?</p><ul id="l30"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">connect()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">write()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">…</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">close()</p></li></ul></li><li data-list-text="b)"><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">dla protokołu UDP?</p><ul id="l31"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendto()</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">…</p></li><li data-list-text=""><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">close()</p></li></ul></li></ol></li><li data-list-text="11."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">W jaki sposób w serwerze UDP (gniazdo niepołączone) i TCP można uzyskać</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">informacje:</p><table style="border-collapse:collapse" cellspacing="0"><tr style="height:16pt"><td style="width:66pt"><p class="s6" style="padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">UDP (npoł.)</p></td><td style="width:31pt"><p class="s6" style="padding-left: 8pt;text-indent: 0pt;line-height: 14pt;text-align: left;">-&gt;</p></td><td style="width:137pt"><p class="s6" style="padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;">recvfrom()</p></td></tr><tr style="height:15pt"><td style="width:66pt"><p class="s6" style="padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">UDP (poł.)</p></td><td style="width:31pt"><p class="s6" style="padding-left: 8pt;text-indent: 0pt;line-height: 14pt;text-align: left;">-&gt;</p></td><td style="width:137pt"><p class="s6" style="padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;">getpeername()</p></td></tr><tr style="height:15pt"><td style="width:66pt"><p class="s6" style="padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">TCP</p></td><td style="width:31pt"><p class="s6" style="padding-left: 8pt;text-indent: 0pt;line-height: 14pt;text-align: left;">-&gt;</p></td><td style="width:137pt"><p class="s6" style="padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;">accept() / getpeername()</p></td></tr><tr style="height:18pt"><td style="width:234pt" colspan="3"><p class="s6" style="padding-top: 2pt;padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">o porcie źródłowym pakietu?</p></td></tr><tr style="height:17pt"><td style="width:66pt"><p class="s6" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">UDP (npoł.)</p></td><td style="width:31pt"><p class="s6" style="padding-top: 1pt;padding-left: 8pt;text-indent: 0pt;line-height: 14pt;text-align: left;">-&gt;</p></td><td style="width:137pt"><p class="s6" style="padding-top: 1pt;padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;">recvfrom()</p></td></tr><tr style="height:16pt"><td style="width:66pt"><p class="s6" style="padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">UDP (poł.)</p></td><td style="width:31pt"><p class="s6" style="padding-left: 8pt;text-indent: 0pt;line-height: 14pt;text-align: left;">-&gt;</p></td><td style="width:137pt"><p class="s6" style="padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;">getpeername()</p></td></tr><tr style="height:15pt"><td style="width:66pt"><p class="s6" style="padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">TCP</p></td><td style="width:31pt"><p class="s6" style="padding-left: 8pt;text-indent: 0pt;line-height: 14pt;text-align: left;">-&gt;</p></td><td style="width:137pt"><p class="s6" style="padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;">accept() / getpeername()</p></td></tr><tr style="height:17pt"><td style="width:234pt" colspan="3"><p class="s6" style="padding-top: 2pt;padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">o adresie docelowym pakietu?</p></td></tr><tr style="height:17pt"><td style="width:66pt"><p class="s6" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">UDP (npoł.)</p></td><td style="width:31pt"><p class="s6" style="padding-top: 1pt;padding-left: 8pt;text-indent: 0pt;line-height: 14pt;text-align: left;">-&gt;</p></td><td style="width:137pt"><p class="s6" style="padding-top: 1pt;padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;">recvmsg()</p></td></tr><tr style="height:16pt"><td style="width:66pt"><p class="s6" style="padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">UDP (poł.)</p></td><td style="width:31pt"><p class="s6" style="padding-left: 8pt;text-indent: 0pt;line-height: 14pt;text-align: left;">-&gt;</p></td><td style="width:137pt"><p class="s6" style="padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;">getsockname()</p></td></tr><tr style="height:16pt"><td style="width:66pt"><p class="s6" style="padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">TCP</p></td><td style="width:31pt"><p class="s6" style="padding-left: 8pt;text-indent: 0pt;line-height: 14pt;text-align: left;">-&gt;</p></td><td style="width:137pt"><p class="s6" style="padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;">getsockname()</p></td></tr><tr style="height:17pt"><td style="width:234pt" colspan="3"><p class="s6" style="padding-top: 2pt;padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">o porcie docelowym pakietu?</p></td></tr><tr style="height:17pt"><td style="width:66pt"><p class="s6" style="padding-top: 1pt;padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">UDP (npoł.)</p></td><td style="width:31pt"><p class="s6" style="padding-top: 1pt;padding-left: 8pt;text-indent: 0pt;line-height: 14pt;text-align: left;">-&gt;</p></td><td style="width:137pt"><p class="s6" style="padding-top: 1pt;padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;">getsockname()</p></td></tr><tr style="height:15pt"><td style="width:66pt"><p class="s6" style="padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">UDP (poł.)</p></td><td style="width:31pt"><p class="s6" style="padding-left: 8pt;text-indent: 0pt;line-height: 14pt;text-align: left;">-&gt;</p></td><td style="width:137pt"><p class="s6" style="padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;">getsockname()</p></td></tr><tr style="height:15pt"><td style="width:66pt"><p class="s6" style="padding-left: 2pt;text-indent: 0pt;line-height: 14pt;text-align: left;">TCP</p></td><td style="width:31pt"><p class="s6" style="padding-left: 8pt;text-indent: 0pt;line-height: 14pt;text-align: left;">-&gt;</p></td><td style="width:137pt"><p class="s6" style="padding-left: 13pt;text-indent: 0pt;line-height: 14pt;text-align: left;">getsockname()</p></td></tr></table><p style="text-indent: 0pt;text-align: left;"/><ol id="l32"><li data-list-text="a)"><p style="padding-top: 3pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">o adresie źródłowym pakietu?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 12pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">b)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 12pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">c)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 12pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">d)</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li></ol></li><li data-list-text="12."><p class="s1" style="padding-top: 12pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">W jaki sposób w kliencie UDP (gniazdo niepołączone) i TCP można uzyskać powyższe informacje?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Chyba tak samo tylko accept() nie będzie działał.</p></li><li data-list-text="13."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać, aby odebrać informację z nagłówka pakietu IP funkcją recvmsg()?</p><ol id="l33"><li data-list-text="1."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawić opcje, które chcemy odbierać funkcją setsockopt()</p></li><li data-list-text="2."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wywołać funkcję recvmsg(), która oprócz danych datagramu przekazuje żądane</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">informacje</p></li><li data-list-text="3."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Odczytać za pomocą makr żądaną opcję</p></li></ol></li><li data-list-text="14."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jak powinny zostać ustawione adresy w funkcjach wysyłających dla protokołu UDP i TCP?</p><ul id="l34"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">UDP (poł.) – adres ustawiamy funkcją connect(), możemy używać send(), write(); lub</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">sendto() bez ustawionego adresu</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">UDP (npoł.) – używamy funkcji sendto() z ustawionym adresem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">TCP – write(), send(); sendto() bez adresu</p></li></ul></li><li data-list-text="15."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jak działa serwer współbieżny dla protokołu UDP.</p></li></ol><ol id="l35"><li data-list-text="1."><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Działa serwer i wywołuje funkcję recvfrom().</p></li><li data-list-text="2."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">W momencie odebrania żądania od klienta wywołany jest fork() i znowu recvfrom().</p></li><li data-list-text="3."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Od tego momentu kolejne datagramy wysyłane są pomiędzy danym klientem, a</p></li></ol><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">serwerem (potomkiem) z nowo utworzonym innym gniazdem</p><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Laboratorium 5</h1><ol id="l36"><li data-list-text="1."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jaki prefiks mają adresy IP typu multicast dla:</p><ol id="l37"><li data-list-text="a."><p style="padding-top: 3pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">IPv4</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">224.0.0.0 – 239.255.255.255</p></li><li data-list-text="b."><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 18pt;line-height: 111%;text-align: left;">IPv6 ffxx::/8</p></li></ol></li><li data-list-text="2."><p class="s1" style="padding-left: 29pt;text-indent: -18pt;text-align: left;">Jaki prefiks mają adresy MAC typu multicast dla:</p><ol id="l38"><li data-list-text="a."><p style="padding-top: 3pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">IPv4</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">01-00-5E-00-00-00 through 01-00-5E-7F-FF-FF</p></li><li data-list-text="b."><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">IPv6</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">33-33-00-00-00-00 through 33-33-FF-FF-FF-FF</p></li></ol></li><li data-list-text="3."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jaki adres warstwy drugiej mają pakiety wysyłane na adres broadcast protokołu IPv4 i IPv6?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: left;">FF-FF-FF-FF-FF-FF</p></li><li data-list-text="4."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie kroki należy wykonać w programie, aby można było wysłać pakiet na</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">adres multicast?</p><ol id="l39"><li data-list-text="1."><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Tworzy gniazdo UDP</p></li><li data-list-text="2."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wysyła pakiet na adres typu multicast</p></li></ol></li><li data-list-text="5."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie kroki należy wykonać w programie aby można było odebrać pakiet</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">adresowany na adres typu multicast?</p><ol id="l40"><li data-list-text="1."><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Tworzy gniazdo UDP</p></li><li data-list-text="2."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Przyłącza się grupy multicastowej</p></li><li data-list-text="3."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Dowiązuje się gniazda na określonym porcie</p></li><li data-list-text="4."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Odbiera pakiety</p></li></ol></li><li data-list-text="6."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie kroki należy wykonać w programie, aby można było wysłać pakiet na</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">adres broadcast?</p><ul id="l41"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Datagram może być wysłany na adres rozgłoszeniowy jedynie gdy dla gniazda jest</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">ustawiona opcja SO_BROADCAST</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Pakiety wysyłane na adres rozgłoszeniowy są także odbierane przez stacje wysyłającą</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">– rozgłaszany datagram ma być wysłany do wszystkich stacji w podsieci</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Nie wolno wysyłać pakietów ICMP o niedostępności usługi dla rozgłaszania</p></li></ul></li><li data-list-text="7."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie kroki należy wykonać w programie, aby można było odebrać pakiet</p></li></ol><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">adresowany na adres typu broadcast?</p><ul id="l42"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Serwer rozsyła pakiety z określonym odstępem czasu – klient tylko nasłuchuje</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Klient wysyła zapytanie na adres rozgłoszeniowy i czeka na odpowiedź (klient nie zna</p></li></ul><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">adresu serwera) – service discovery</p><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Pytania – wejściówka 3</h1><ol id="l43"><li data-list-text="1."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">W procesie odbierającym adres docelowy datagramu przychodzącego dla połączonego gniazda UDP można pobrać:</p><ol id="l44"><li data-list-text="a."><p class="s5" style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcją getsockname()</p></li><li data-list-text="b."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcją getsockopt()</p></li><li data-list-text="c."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcją recvfrom()</p></li><li data-list-text="d."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcją getpeername()</p></li></ol></li><li data-list-text="2."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">W procesie odbierającym adres docelowy IP (destination address) datagramu przychodzącego dla niepołączonego gniazda UDP można pobrać. Wybierz jedną odpowiedź<span class="s7">:</span></p><ol id="l45"><li data-list-text="a."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcją getsockopt()</p></li><li data-list-text="b."><p class="s5" style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcją recvmsg()</p></li><li data-list-text="c."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcją getpeername()</p></li><li data-list-text="d."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcją getsockname()</p></li></ol></li><li data-list-text="3."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">W procesie adres docelowy gniazda połączonego TCP można pobrać. Wybierz jedną odpowiedź:</p><ol id="l46"><li data-list-text="a."><p class="s5" style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcją getpeername()</p></li><li data-list-text="b."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcją getsockname()</p></li><li data-list-text="c."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcją recvmsg()</p></li><li data-list-text="d."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcją getsockopt()</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;"><span><table border="0" cellspacing="0" cellpadding="0"><tr><td><img width="315" height="216" src="data:image/jpg;base64,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"/></td></tr></table></span></p></li></ol></li><li data-list-text="4."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">W procesie adres źródłowy gniazda nasłuchującego TCP można pobrać:</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">funkcją getsockname()</p></li><li data-list-text="5."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">W procesie odbierającym adres źródłowy odebranego datagramu dla niepołączonego gniazda UDP można pobrać</p><p class="s8" style="padding-left: 11pt;text-indent: 0pt;text-align: left;">funkcją recvfrom(), funkcją getpeername()</p></li><li data-list-text="6."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Dla gniazda połączonego UDP do wysyłania datagramów można użyć</p><p class="s8" style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">funkcji send()</p></li><li data-list-text="7."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Dla gniazda niepołączonego UDP do wysyłania datagramów można użyć:</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Funkcji sendto() z określonym adresem docelowym</p></li><li data-list-text="8."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Dla gniazda <span style=" color: #00AF50;">połączonego </span>(<span style=" color: #FFC000;">niepołączonego</span>) UDP do wysyłania datagramów można użyć:</p><ol id="l47"><li data-list-text="a."><p class="s5" style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcji sendto() bez określonego adresu docelowego (z adresem docelowym</p><p class="s5" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">ustawionym na NULL)</p></li><li data-list-text="b."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcji write() z określonym adresem docelowym</p></li><li data-list-text="c."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcji send() z adresem docelowym ustawionym na NULL</p></li><li data-list-text="d."><p class="s11" style="padding-left: 47pt;text-indent: -18pt;text-align: left;">funkcji sendmsg() z określonym adresem docelowym</p></li></ol></li><li data-list-text="9."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Prefiks dla adresu typu Solicited-Node Address ma postać FF02:0:0:0:0:1:FF00::/104. Podaj adres typu Solicited-Node Address (multicast) dla adresu 2001:6d8:10:105d:1c4f:666f:3811:3737:</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 14pt;text-align: left;">FF02:0:0:0:0:1:FF11:3737</p></li><li data-list-text="10."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Podaj adres Ethernet na który zostanie wysłana ramka z datagramem</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">wysłanym na adres ff02::fb</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">33:33:00:00:00:fb</p></li><li data-list-text="11."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Podaj adres rozgłoszeniowy skierowany do podsieci dla sieci 149.223.0.0/24</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">149.223.0.255</p></li><li data-list-text="12."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie kroki należy wykonać w programie, aby wysłać pakiet na adres</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;line-height: 111%;text-align: left;">224.1.1.1 na port 12345? Opisz podstawowe funkcje, co wywoływane funkcje wykonują, najważniejsze struktury danych.</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Strona nadająca:</p><ul id="l48"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">tworzy gniazdo - funkcja socket()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">wysyła pakiet UDP na adres multicastowy - funkcja sendto()/sendmsg()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">stworzyć strukturę sockaddr_in cliaddr:</p><ul id="l49"><li data-list-text="o"><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">cliaddr.sin_family = AF_INET;</p></li><li data-list-text="o"><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">cliaddr.sin_port = htons(12345);</p></li><li data-list-text="o"><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">inet_pton(AF_INET, “224.1.1.1”, &amp;cliaddr.sin_addr);</p></li></ul></li></ul></li><li data-list-text="13."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby wysłać pakiet na adres fc00:1::21 dla protokołu UDP na port 11 z portu 22? Opisz podstawowe funkcje, co wywoływane funkcje wykonują, najważniejsze struktury danych.</p><ul id="l50"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket()-tworzymy gniazdo niepołączone</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind()-przekazanie numeru portu do tej funkcji</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysyłanie wiadomości do gniazda</p><ul id="l51"><li data-list-text="o"><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">const struct sockaddr *dest_addr</p></li></ul></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendmsg() - umożliwia wysłanie dodatkowych informacji sterujących</p><ul id="l52"><li data-list-text="o"><p style="padding-left: 83pt;text-indent: -18pt;text-align: left;">struct msghdr msg;</p></li><li data-list-text="o"><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">struct cmsghdr *cmsg;</p></li><li data-list-text="o"><p style="padding-left: 83pt;text-indent: -18pt;line-height: 15pt;text-align: left;">struct in_pktinfo *pktinfo;</p></li></ul></li></ul></li><li data-list-text="14."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby wysłać pakiet na adres 192.168.1.1 dla protokołu UDP na port 21 z portu 11? Opisz podstawowe funkcje, co wywoływane funkcje wykonują, najważniejsze struktury danych.</p><ul id="l53"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket(AF_INET, SOCK_DGRAM, 0) - stworzenie gniazda UDP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">struktura sockaddr_in dest_addr, z adresem 192.168.1.1 i portem 21.</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">struktura sockaddr_in local_addr z portem 11 dla lokalnej aplikacji.</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind(sockfd, local_addr, sizeof(local_addr)) - przyłączenie gniazda do konkretnego</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">portu</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto(sockfd, msg, sizeof(msg), 0, dest_addr, sizeof(dest_addr)) - wysłanie pakietu, brak flag, albo sendmsg(), ale trzeba zbudować strukturę msghdr.</p></li></ul></li><li data-list-text="15."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać, aby ustawić wartość adresu źródłowego w nagłówku pakietu IP w wysyłanym datagramie UDP. Opisz podstawowe funkcje, co wywoływane funkcje wykonują, najważniejsze struktury danych.</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Należy wysłać datagram UDP za pomocą sendmsg():</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Inicjalizacja struktury msghdr i cmsghdr (odpowiedni przydział pamięci) z pomocą makr</p><ul id="l54"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawienie danej opcji: IP_PKTINFO</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wysłanie datagramu funkcją sendmsg()</p></li></ul></li><li data-list-text="16."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby odebrać pakiet adresowany na adres typu broadcast na port 456? Opisz podstawowe funkcje, co wywoływane funkcje wykonują, najważniejsze struktury danych.</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">socket() - utworzenie gniazda UDP bind() - połączenie gniazda recvfrom() - funkcja odbierająca</p></li><li data-list-text="17."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie funkcje sieciowe należy wywołać po stronie serwera, aby można było odebrać pakiet od klienta dla protokołu TCP na porcie 123. Opisz podstawowe funkcje, co wywoływane funkcje wykonują, najważniejsze struktury danych.</p><ol id="l55"><li data-list-text="a."><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - gniazdo niepołączone</p></li><li data-list-text="b."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() - określenie adresu pod który wysyłamy</p></li><li data-list-text="c."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">const struct sockaddr *addr</p></li><li data-list-text="d."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">listen() - zmienia stan gniazda z gniazda niepołączonego na gniazdo pasywne, które oczekuje na połączenia</p></li><li data-list-text="e."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">accept() - zwraca gniazdo połączone dla zaakceptowanego połączenia oraz adres drugiej strony połączenia</p></li><li data-list-text="f."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">struct sockaddr *addr</p></li><li data-list-text="g."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">read() - czytanie bajtów z deskryptora</p></li></ol></li><li data-list-text="18."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Funkcja connect() dla protokołu UDP umożliwia. Wybierz jedną odpowiedź:</p><ol id="l56"><li data-list-text="a."><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">zmianę gniazda nasłuchującego na połączone</p></li><li data-list-text="b."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">oczekiwanie na wybranym adresie i porcie</p></li><li data-list-text="c."><p class="s5" style="padding-left: 47pt;text-indent: -18pt;text-align: left;">ustalenie adresu docelowego dla wysyłanych datagramów dla funkcji write()</p></li><li data-list-text="d."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">oczekiwanie na wybranym porcie</p></li><li data-list-text="e."><p class="s5" style="padding-top: 4pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Otrzymywanie błędów asynchronicznych przez gniazdo</p></li></ol></li><li data-list-text="19."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Co należy zrobić w procesie, aby była możliwość odczytania informacji z nagłówka IP przychodzącego datagramu UDP (np. wartość adresu docelowego datagramu)? Opisz podstawowe funkcje, co wywoływane funkcje wykonują, najważniejsze struktury danych.</p><ol id="l57"><li data-list-text="1."><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">odebrać pakiet recvmsg() do struktury msghdr</p></li><li data-list-text="2."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">odczytać z tej niej strukturę cmsghdr</p></li><li data-list-text="3."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">odczytać structurę pktinfo z cmsghdr i odpowiednie pole</p></li></ol></li><li data-list-text="20."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do procesu klienta wysyłany jest sygnał SIGPIPE gdy:</p><ol id="l58"><li data-list-text="a."><p class="s5" style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">gniazdo połączone TCP otrzymało segment RST a proces klienta wywołał funkcję piszącą do gniazda</p></li><li data-list-text="b."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">gniazdo nasłuchujące UDP otrzymało segment RST a proces klienta wywołał funkcję piszącą do gniazda</p></li><li data-list-text="c."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">gniazdo niepołączone TCP otrzymało segment RST a proces klienta wywołał funkcję piszącą do gniazda</p></li><li data-list-text="d."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">gniazdo połączone TCP otrzymało segment RST a proces klienta wywołał funkcję czytającą z gniazda</p></li><li data-list-text="e."><p class="s5" style="padding-left: 47pt;text-indent: -18pt;line-height: 14pt;text-align: left;">proces serwera TCP został zakończony (zostało zamknięte gniazdo po stronie serwera)</p><p class="s5" style="padding-top: 1pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">a proces klienta pisze do gniazda w pętli ignorując błędy</p></li></ol></li><li data-list-text="21."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Do procesu serwera wysyłany jest sygnał SIGPIPE gdy - wybierz jedną odpowiedź:</p><ol id="l59"><li data-list-text="a."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">gniazdo połączone TCP otrzymało segment RST a proces serwera wywołał funkcję czytającą z gniazda</p></li><li data-list-text="b."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">gniazdo połączone UDP otrzymało segment RST a proces klienta wywołał funkcję piszącą do gniazda</p></li><li data-list-text="c."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">gniazdo niepołączone TCP otrzymało segment RST a proces klienta wywołał funkcję piszącą do gniazda</p></li><li data-list-text="d."><p class="s5" style="padding-left: 47pt;text-indent: -18pt;line-height: 14pt;text-align: left;">proces klienta TCP został zakończony (zostało zamknięte gniazdo po stronie klienta) a</p><p class="s5" style="padding-left: 47pt;text-indent: 0pt;text-align: left;">proces serwera pisze do gniazda w pętli ignorując błędy</p></li></ol></li><li data-list-text="22."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Proces nie przechodzi przez stan &quot;zombi&quot; jeśli. Wybierz jedną odpowiedź:</p><ol id="l60"><li data-list-text="a."><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">program macierzysty niejawnie zignorował sygnał SIGPIPE</p></li><li data-list-text="b."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">program macierzysty jawnie zignorował sygnał SIGCHILD funkcją sigaction()</p></li><li data-list-text="c."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">program macierzysty niejawnie zignorował sygnał SIGCHILD funkcja sigaction()</p></li><li data-list-text="d."><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">program macierzysty wywołał funkcję waitpid()</p></li></ol></li></ol><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: center;">Laboratorium 6</h1><ol id="l61"><li data-list-text="1."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Ile minimum gniazd dla protokołu SCTP jest wymaganych do komunikacji z X</p><p class="s1" style="padding-top: 3pt;padding-left: 11pt;text-indent: 0pt;text-align: center;">klientami dla</p><ol id="l62"><li data-list-text="a."><p style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">Trybu one-to-one x+1</p></li><li data-list-text="b."><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">Trybu one-to-many 1</p></li><li data-list-text="c."><p style="padding-top: 2pt;padding-left: 22pt;text-indent: -10pt;text-align: left;">Trybu ‘tcp’</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">x+1</p></li><li data-list-text="d."><p style="padding-top: 4pt;padding-left: 23pt;text-indent: -11pt;text-align: left;">Trybu ‘udp’</p></li></ol><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">1</p></li><li data-list-text="2."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Opisz procedurę nawiązania połączenia dla protokołu SCTP</p><ol id="l63"><li data-list-text="1."><p style="padding-top: 9pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Klient wysyła INIT(Ta, J)</p></li><li data-list-text="2."><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Serwer odpowiada Ta:INIT-ACK(Tz, K, cookie C)</p></li><li data-list-text="3."><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Klient – Tz: COOKIE-ECHO C</p></li><li data-list-text="4."><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Serwer – Ta: COOKIE-ACK</p></li></ol></li><li data-list-text="3."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Opisz procedurę kończenia połączenia dla protokołu SCTP</p><ol id="l64"><li data-list-text="1."><p style="padding-top: 9pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Strona aktywnie zamykająca wysyła SHUTDOWN</p></li><li data-list-text="2."><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Strona pasywnie zamykająca odpowiada SHUTDOWN-ACK</p></li><li data-list-text="3."><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Strona pierwsza kończy SHUTDOWN-COMPLETE</p></li><li data-list-text="4."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jaka jest struktura pakietu SCTP?</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">Common Header – port źródłowy, port docelowy, verification tag, checksum Chunk 1 – type, flags, length, data</p></li><li data-list-text="5."><p class="s1" style="padding-top: 7pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Stany protokołu SCTP</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">CLOSED COOKIE WAIT</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">COOKIE ECHOED ESTABLISHED PENDING SHUTDOWN SHUTDOWN SENT SHUTDOWN RECEIVED SHUTDOWN-ACK-SENT CLOSED</p></li><li data-list-text="6."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Różnice pomiędzy SCTP i TCP dla trybu one-to-one</p><ul id="l65"><li data-list-text=""><p style="padding-top: 8pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Struktura aplikacji jest podobna ale gdy przerabiamy aplikację TCP na SCTP to wszystkie opcje gniazd muszą być zastąpione odpowiednikami dla protokołu SCTP o ile istnieją: np. TCP_NODELAY i TCP_MAXSEG na SCTP_NODELAY i SCTP_MAXSEG.</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Strumień bajtów versus strumień dtagramów: SCTP zachowuje informacje o końcach komunikatów, tzn. że podczas jednego wywołania funkcji read() nie odbierzemy danych z dwóch komunikatów.</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Gdy TCP używa zamknięcia jednego kierunku transmisji, to należy przerobić aplikację</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">ponieważ SCTP tej funkcjonalności nie wspiera.</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Mogą być używane funkcje do wysyłania z ustawionym adresem (np. sendto) ale</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">wtedy nadpisujemy primary destination address.</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Gniazdo SCTP one-to-one jest gniazdem (z rodziny AF_INET lub AF_INET6), o typie SOCK_STREAM i protokole IPPROTO_SCTP.</p></li></ul></li><li data-list-text="7."><p class="s1" style="padding-top: 8pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Różnice pomiędzy SCTP i UDP dla trybu one-to-many</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 118%;text-align: left;">SCTP w trybie one-to-many używa adresów unicastowych, po prostu tworząc wiele asocjacji dla jednego gniazda, natomiast w przypadku UDP do tego celu użyjemy adresu multicastowego.</p></li><li data-list-text="8."><p class="s1" style="padding-top: 8pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">W jaki sposób można utworzyć nową asocjację w protokole SCTP?</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="9."><p class="s1" style="padding-top: 13pt;padding-left: 29pt;text-indent: -18pt;line-height: 118%;text-align: left;">Ile maksymalnie strumieni może być przesyłanych w asocjacji SCTP? Jaką maksymalną liczbę strumieni może obsłużyć asocjacja SCTP biorąc pod uwagę strukturę nagłówka SCTP?</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="10."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Czym różni się użycie funkcji connect() od sctp_connect() dla protokołu SCTP</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="11."><p class="s1" style="padding-top: 13pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Czym różni się użycie funkcji bind() od sctp_bindx() dla protokołu SCTP</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">sctp_bindx() pozwala podpiąć się do kilku adresów, natomiast w przypadku pojedynczego (lub wszystkich) można użyć bind().</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="12."><p class="s1" style="padding-left: 29pt;text-indent: -18pt;text-align: left;">Jak rozpoznać w protokole SCTP, że zostały odebrane wszystkie fragmenty</p><p class="s1" style="padding-top: 3pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">pakietu.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="13."><p class="s1" style="padding-top: 13pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie podstawowe parametry opisują asocjację SCTP?</p></li></ol></li></ol><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Port źródłowy, tablica adresów źródłowych, port docelowy, tablica adresów docelowych</p><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Laboratorium 7</h1><ol id="l66"><li data-list-text="1."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie modele obsługi można stosować dla gniazd sieciowych?</p><ul id="l67"><li data-list-text=""><p style="padding-top: 8pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Wejścia-wyjścia blokującego</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Wejścia-wyjścia nieblokującego</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Wejścia-wyjścia zwielokrotnionego</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Wejścia-wyjścia sterowanego sygnałami</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Wejścia-wyjścia asynchronicznego</p></li></ul></li><li data-list-text="2."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Kiedy gniazdo jest gotowe do pisania dla funkcji z rodziny select()/poll()?</p><ul id="l68"><li data-list-text=""><p style="padding-top: 8pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Bufor nadawczy gniazda nie jest pełny – write() zwróci liczbę zapisanych bajtów</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Została zamknięta część pisząca połączenia (write() wygeneruje sygnał SIGPIPE)</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;line-height: 118%;text-align: left;">Istnieje nieobsłużony błąd dotyczący gniazda (write() zwróci -1) – błąd można obsłużyć funkcją getsockopt() z opcją SO_ERROR</p></li></ul></li><li data-list-text="3."><p class="s1" style="padding-top: 8pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Kiedy gniazdo jest gotowe do czytania dla funkcji z rodziny select()/poll()?</p><ul id="l69"><li data-list-text=""><p style="padding-top: 8pt;padding-left: 47pt;text-indent: -18pt;line-height: 118%;text-align: left;">Liczba bajtów w buforze odbiorczym gniazda jest większa lub równa 1 – funkcja read() zwróci liczbę przeczytanych bajtów</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Została zamknięta część czytająca połączenia (funkcja read() zwróci 0)</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;line-height: 118%;text-align: left;">Istnieje nieobsłużony błąd dotyczący gniazda (funkcja read() zwróci -1) – błąd można obsłużyć funkcją getsockopt() z opcją SO_ERROR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 118%;text-align: left;">Operacja dotyczy gniazda nasłuchującego, a liczba nawiązanych połączeń jest większa od zera (można wywołać funkcję accept() dla gniazda)</p></li></ul></li><li data-list-text="4."><p class="s1" style="padding-top: 7pt;padding-left: 29pt;text-indent: -18pt;line-height: 119%;text-align: left;">Jakie różnice można zaobserwować w działaniu serwera współbieżnego z użyciem funkcji z rodziny select() i serwera współbieżnego z użyciem funkcji fork(), przy użyciu poleceń netstat (ss) i tcpdump (wireshark)?</p><p style="padding-top: 5pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Przy funkcji fork() gniazda słuchające i ustanowione (established) działają w ramach nowych</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">procesów. Dla selecta() jest to ten sam proces.</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">W wiresharku nie ma różnic, ale za pomocą nestata (ss) można zobaczyć pidy procesów i widać czy pidy procesów się różnią - fork(), czy nie -select()</p></li><li data-list-text="5."><p class="s1" style="padding-top: 7pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Co zwraca funkcja select()?</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Funkcja zwraca liczbę gotowych deskryptorów, 0 jeśli został przekroczony czas oczekiwania,</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">-1 w przypadku błędu</p></li><li data-list-text="6."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Co zwraca funkcja poll()?</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Funkcja zwraca liczbę deskryptorów dla których wystąpiło zadane zdarzenie</p></li><li data-list-text="7."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Co zwraca funkcja epoll_wait()?</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">Zwraca liczbę deskryptorów gotowych na żądania I/O. Zwraca 0 jeśli nie ma gotowych , błąd zwraca -1. Pozwala obsługiwać więcej niż jeden deskryptor przez proces klienta</p></li><li data-list-text="8."><p class="s1" style="padding-top: 7pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Czym rożni się funkcja select() od pselect()?</p><ul id="l70"><li data-list-text=""><p style="padding-top: 8pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Pselect() korzysta ze struktury timespec (a select() korzysta z timeval) czas można podawać z dokładnością do nanosekund</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Nowy argument sigmask – na czas wywołania pselect() możemy zmieniać maskę sygnałów (blokować/odblokowywać lub ustawiać procedury obsługi sygnałów)</p></li></ul></li><li data-list-text="9."><p class="s1" style="padding-top: 8pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Czym rożni się funkcja poll() od ppoll()?</p><ul id="l71"><li data-list-text=""><p style="padding-top: 8pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Funkcja analogiczna do funkcji poll(), ale umożliwia zmianę maski sygnałów w trakcie wywołania funkcji.</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Stosuje strukturę timespec, w której czas oczekiwania można podać z dokładnością</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">do nanosekund.</p></li></ul></li><li data-list-text="10."><p class="s1" style="padding-top: 8pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Czym rożni się tryb &#39;level-triggered&#39; i &#39;edge-trigered&#39; dla mechanizmu epoll?</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">Edge-triggered przekazuje zdarzenia tylko gdy wystąpi jakaś zmiana w monitorowanym deskryptorze. Działa jeżeli interfejs używa flagi EPOLLET.</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 14pt;text-align: left;">W trypie level-triggered – epoll() to szybszy poll()</p></li><li data-list-text="11."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Dlaczego należy stosować gniazda nieblokujące dla funkcji typu</p><p class="s1" style="padding-top: 3pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">select()/poll() i mechanizmu epoll?</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Żeby gniazda się nie zablokowały i pętla mogła działać</p></li><li data-list-text="12."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;line-height: 118%;text-align: left;">Dlaczego musimy stosować gniazda nieblokujące dla trybu &#39;edge-trigered&#39; dla mechanizmu epoll?</p><p style="padding-top: 6pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Musimy je stosować, żeby przy użyciu operacji blokującej read() lub write() nie sprawić, że Edge-triggered reaguje tylko na otrzymanie nowych danych. W przypadku odczytania tylko części wiadomości zablokowałby się cały proces, bo Edge-trigerred nie wykryłoby nowych danych, a write() i read() by je blokowały.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="13."><p class="s1" style="padding-left: 29pt;text-indent: -18pt;text-align: left;">Jak działa mechanizm epoll - czym różni się od użycia funkcji poll()?</p><ul id="l72"><li data-list-text=""><p style="padding-top: 8pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Podobny do poll(), ale szybszy</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Przechowuje tabelę deskryptorów w kernelu</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">EPOLL - ograniczenie na maksymalną liczbę obserwowanych deskryptorów EPOLL API</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Funkcja poll() oczekuje na zdarzenia na grupie deskryptorów i gdy wystąpi określone</p><p style="padding-top: 2pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">zdarzenie budzi proces</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Podobne zastosowanie do funkcji select(), ale dostarcza dodatkowe informacje</p></li></ul></li></ol><p style="padding-top: 2pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">związane z obsługą urządzeń strumieniowych (stosuje się nie tylko do gniazd)</p><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Pytania – wejściówka 4</h1><ol id="l73"><li data-list-text="1."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie kroki należy wykonać w programie, aby wysłać pakiet na adres</p><p class="s1" style="padding-top: 3pt;padding-left: 29pt;text-indent: 0pt;line-height: 118%;text-align: left;">224.1.1.1 na port 13 z portu 2222? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd.</p><p class="s2" style="padding-top: 6pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">socket<span class="p">() - tworzymy gniazdo niepołączone</span></p><ul id="l74"><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">ustawiamy opcje (nieobowiązkowe): • setsockopt()</p><p class="s2" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">bind<span class="p">() - przekazanie numeru portu do tej funkcji sendto() - wysyłanie wiadomości do gniazda</span></p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">const struct sockaddr *<i>dest_addr</i></p><p class="s2" style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">sendmsg() - <span class="p">umożliwia wysłanie dodatkowych informacji sterujących</span></p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">struct msghdr msg;</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">struct cmsghdr *cmsg;</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">struct in_pktinfo *pktinfo;</p></li></ul></li><li data-list-text="2."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;line-height: 118%;text-align: left;">Jakie kroki należy wykonać w programie, aby wysłać pakiet na adres 255.255.255.255 na port 21 z portu 66. Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><p style="padding-top: 6pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">sock() - otwiera gniazdo</p><ul id="l75"><li data-list-text=""><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 18pt;line-height: 118%;text-align: left;">Ustawiamy opcje– setsockopt(SO_BROADCAST) bind() - określenie adresu pod który wysyłamy</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">sendto()</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 18pt;line-height: 118%;text-align: left;">const struct sockaddr *<i>dest_addr </i>sendmsg()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">struct msghdr msg;</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">struct cmsghdr *cmsg;</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">struct in_pktinfo *pktinfo;</p></li></ul></li><li data-list-text="3."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;line-height: 119%;text-align: left;">Jakie funkcje sieciowe należy wywołać w procesie A, aby wysłać pakiet do serwera B na port 123 a następnie odebrać pakiet od klienta C na porcie 123 dla protokołu SCTP w trybie ‘one-to-many’. Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><p style="padding-top: 5pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">socket() - tworzy gniazdo</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">bind() - przypisuje adres do socketu</p><p style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">listen() - nasłuchiwanie sctp_sendto() - wysyła pakiet sctp_recvmsg() - odbiera pakiet</p></li><li data-list-text="4."><p class="s1" style="padding-top: 7pt;padding-left: 29pt;text-indent: -18pt;line-height: 119%;text-align: left;">Jakie funkcje sieciowe należy wywołać po stronie serwera, aby odebrać pakiet od klienta dla protokołu SCTP na porcie 123 w trybie ‘one-to-many’. Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><p style="padding-top: 5pt;padding-left: 11pt;text-indent: 0pt;line-height: 160%;text-align: left;">socket() - gniazdo niepołączone bind() - określenie adresu listen() - nasłuchiwanie</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 14pt;text-align: left;">sctp_recvmsg() - funkcja odbierająca</p><ul id="l76"><li data-list-text=""><p style="padding-top: 8pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">ssize_t sctp_recvmsg(int s, void *msg, size_t len, struct sockaddr *from, socklen_t</p><p style="padding-top: 2pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">*fromlen, struct sctp_sndrcvinfo *sinfo, int*msg_flags);</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">ja mam jeszcze accept() i read() ale też nie pelna liczba pkt</p></li></ul></li><li data-list-text="5."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;line-height: 118%;text-align: left;">Jakie funkcje sieciowe należy wywołać po stronie serwera, aby odebrać pakiet od klienta dla protokołu TCP na porcie 123. Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><p style="padding-top: 6pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">socket() - utworzenie gniazda, setsockopt: SOCK_STREAM</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">bind () - dowiązanie gniazda, w argumentach port 123 i adres IP serwera listen() - nasłuchiwanie</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: left;">accept() - do zwrócenia gniazda połączonego</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">read() - odebranie wiadomości</p></li><li data-list-text="6."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;line-height: 119%;text-align: left;">Jakie funkcje sieciowe należy wywołać w procesie A, aby wysłać pakiet do serwera B na port 123 a następnie odebrać pakiet od klienta C na porcie 123 dla protokołu SCTP w trybie ‘one-to-many’. Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji. --1/2</p><p style="padding-top: 5pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">socet() - utworzenie gniazda</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;line-height: 117%;text-align: left;">stcp_bindx(nr portu serwera B-123, adresy serwera B ) - polaczenie sie gniazda (u nas do portu 123 i tablic adresów skorjarzonych z serwerm B i klientami C)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">listen() - nasłuchiwanie</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">sctp_sendmsg(struktura adresowa[port 123],) -wyslanie pakietów do serwera B sctp_recvmsg(struktura adresowa [port 123]) - odebranie pakietów od klienta c na porcie 123</p></li><li data-list-text="7."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 119%;text-align: left;">Jakie kroki należy wykonać w programie, aby odebrać pakiet adresowany na adres typu broadcast na port 456? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><p style="padding-top: 5pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">socket() - tworzymy gniazdo niepołączone</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">bind() - przekazanie numeru portu do tej funkcji</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">recvfrom() / recvmsg() - funkcje odbierające, zwracają adresy nadawcy a do tego recvmsg() odczytuje opcje z nagłówka IP</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Struktury:</p><ul id="l77"><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">struct sockaddr *src_addr (recvfrom())</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">struct msghdr *msg (recvmsg())</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">struct cmsghdr</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Aby wysłać pakiet na adres broadcast trzeba dodatkowo na gnieździe ustawić opcję</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">SO_BROADCAST</p></li></ul></li><li data-list-text="8."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Ile minimum gniazd w procesie jest wymaganych dla protokołu TCP do</p><p class="s1" style="padding-top: 3pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">komunikacji z 7 klientami:</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">8</p></li><li data-list-text="9."><p class="s1" style="padding-top: 8pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Ile minimum gniazd dla protokołu SCTP w trybie „one-to-many” jest</p><p class="s1" style="padding-top: 3pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">wymaganych do komunikacji z 9 klientami</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">1</p></li><li data-list-text="10."><p class="s1" style="padding-top: 8pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">W serwerze ile minimum gniazd dla protokołu SCTP w trybie „one-to-one”</p><p class="s1" style="padding-top: 3pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">jest wymaganych do komunikacji z 7 klientami?</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">8</p></li><li data-list-text="11."><p class="s1" style="padding-top: 8pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Opisz różnice i podobieństwa pomiędzy TCP i SCTP dla trybu one-to-many.</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">TCP nie obsługuje trybu one-to-many.</p></li><li data-list-text="12."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Opisz różnice i podobieństwa pomiędzy TCP i SCTP dla trybu one-to-one</p><ul id="l78"><li data-list-text=""><p style="padding-top: 8pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">SCTP zachowuje informacje o końcach komunikatów.</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Struktura aplikacji jest podobna, ale TCP to strumień bajtów a SCTP datagramów.</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">SCTP nie wspiera jednokierunkowego zamknięcia.</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">SCTP zachowuje granice między komunikatami.</p></li></ul></li><li data-list-text="13."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Co zwraca i jak działa funkcja poll()?</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Zwraca liczbę deskryptorów dla których wystąpiło zadane zdarzenie.</p><p style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Oczekuje na zdarzenia na zbiorze deskryptorów, podobne zastosowanie do funkcji select(),</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">ale dostarcza dodatkowe informacje związane z obsługą urządzeń strumieniowych.</p></li><li data-list-text="14."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Co zwraca i jak działa funkcja select()?</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">Zwraca liczbę gotowych deskryptorów, 0-gdy przekroczono czas oczekiwania, -1 gdy błąd. Jak ją wywołamy to zlecamy jądru systemu operacyjnemu oczekiwanie na pewne wydarzenia</p><ul id="l79"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval</p><p style="padding-top: 2pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">*timeout);</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Funkcja select pozwala programowi monitorować wiele deskryptorów plików.</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Oczekuje na zdarzenia takie jak:</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Dowolny deskryptor ze zbioru jest gotowy do czytania</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Dowolny deskryptor ze zbioru jest gotowy do pisania</p></li><li data-list-text=""><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;line-height: 118%;text-align: left;">Dla dowolnego deskryptora z pewnego zbioru istnieje nie obsłużona sytuacja wyjątkowa</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Upłynęło więcej czasu niż ustalony limit</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Jądro budzi proces jeśli wystąpiło jedno z powyższych zdarzeń</p></li></ul></li><li data-list-text="15."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Opisz procedurę nawiązania połączenia dla protokołu SCTP w trybie</p><p class="s1" style="padding-top: 3pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">„one-to-many”:</p><ol id="l80"><li data-list-text="1."><p style="padding-top: 9pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Klient inicjuje nawiązanie asocjacji (INIT)</p></li><li data-list-text="2."><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Serwer odpowiada komunikatem INIT-ACK, zawierającym także plik cookie, który</p><p style="padding-top: 2pt;padding-left: 47pt;text-indent: 0pt;text-align: left;">identyfikuje połączenie</p></li><li data-list-text="3."><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Klient odsyła otrzymany plik cookie (COOKIE-ECHO)</p></li><li data-list-text="4."><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Serwer wysyła potwierdzenie (COOKIE-ACK)</p></li></ol></li><li data-list-text="16."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;line-height: 118%;text-align: left;">Opisz przejście ze stanu ESTABLISHED do stanu CLOSED dla strony nie inicjującej zamknięcie asocjacji dla protokołu SCTP</p><ol id="l81"><li data-list-text="1."><p style="padding-top: 6pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Otrzymujemy SHUTDOWN, przechodzimy do stanu SHUTDOWN_RECEIVED</p></li><li data-list-text="2."><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Wysyłamy SHUTDOWN-ACK, start shutdown timer</p></li><li data-list-text="3."><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Przechodzimy do stanu SHUTDOWN_ACK-SENT</p></li><li data-list-text="4."><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Otrzymujemy SHUTDOWN-COMPLETE, zatrzymujemy shutdown timer, usuwamy TCB</p></li><li data-list-text="5."><p style="padding-top: 2pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Przechodzimy do stanu CLOSED</p></li></ol></li><li data-list-text="17."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;line-height: 118%;text-align: left;">Opisz przejście ze stanu CLOSED do stanu ESTABLISHED dla serwera protokołu SCTP</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="18."><p class="s1" style="padding-left: 29pt;text-indent: -18pt;text-align: left;">Opisz różnice i podobieństwa pomiędzy UDP i SCTP dla trybu one-to-one</p></li><li data-list-text="19."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 119%;text-align: left;">Jakie funkcje sieciowe należy wywołać w procesie A, aby wysłać pakiet do serwera B na port 123 a następnie odebrać pakiet od klienta C na porcie 123 dla protokołu SCTP w trybie ‘one-to-many’. Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="20."><p class="s1" style="padding-left: 29pt;text-indent: -18pt;text-align: left;">Opisz krótko proces zamykania asocjacji dla protokołu SCTP w trybie</p><p class="s1" style="padding-top: 3pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">„one-to-many”: --0/2</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Poprawna odpowiedź to prawdopodobnie:</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;line-height: 118%;text-align: left;">aktywne zamykanie - shutdown() druga strona - shutdown ack pierwsza strona - shutdown complete</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">(tak bylo w pytaniu o to samo ale dla one-to-one i bylo 2 pkty)</p></li><li data-list-text="21."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;line-height: 118%;text-align: left;">Jakie kroki należy wykonać w programie, aby wysłać pakiet na adres 255.255.255.255 na port 21 z portu 66. Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji. --1/2</p><p style="padding-top: 6pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">socket() - tworzy gniazdo</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">bind(port źródłowy, port docelowy) - powiązanie gniazda z portami</p><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">ustawienie opcji SO_BROADCAST dla socketu sendto() - wysyłanie na adres broadcastowy</p></li><li data-list-text="22."><p class="s1" style="padding-top: 7pt;padding-left: 29pt;text-indent: -18pt;line-height: 119%;text-align: left;">Jakie kroki należy wykonać w programie, aby można było wysłać pakiet na adres ff02:1::1:1 na port 13 z portu 2222? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.-- 0.5/2</p><p style="padding-top: 5pt;padding-left: 11pt;text-indent: 0pt;line-height: 119%;text-align: left;">socket() connect() write()</p></li><li data-list-text="23."><p class="s1" style="padding-top: 7pt;padding-left: 29pt;text-indent: -18pt;line-height: 119%;text-align: left;">Ile maksymalnie strumieni może być przesyłanych w asocjacji SCTP - na którym etapie połączenia jest ten parametr ustalany? Jaką maksymalną liczbę strumieni może obsłużyć asocjacja SCTP biorąc pod uwagę strukturę nagłówka SCTP? --1/2</p></li></ol><p style="padding-top: 5pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">max 2^16</p><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Laboratorium 8</h1><ol id="l82"><li data-list-text="1."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie podstawowe właściwości powinien mieć proces, który ma działać, jako</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">demon w systemie Unix?</p><ul id="l83"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Brak interakcji z użytkownikiem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Proces powinien być odłączony od mechanizmów sterowania procesami związanymi z terminalem (np. otrzymywanie sygnałów związanych z zamknięciem terminala)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Nie powinien pisać do terminala (wykluczamy użycie funkcji printf() i podobnych)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Właścicielem nie powinien być administrator systemu</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Zmiana katalogu domowego dla procesu</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Do raportowania zdarzeń powinien zostać użyty system do logowania (np. syslog) - nie powinien pisać na standardowe wyjście</p></li></ul></li><li data-list-text="2."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Dlaczego od odłączenia się procesu od terminala sterującego wymagane jest wywołanie dwóch funkcji fork()?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Zapobiegamy automatycznemu uzyskaniu terminala sterującego przez nasz proces. Jeśli proces jest przywódcą sesji i otworzy urządzenie terminalowe, to to urządzenie staje się terminalem sterującym.</p></li><li data-list-text="3."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Dlaczego podczas tworzenia procesu demona należy zignorować (obsłużyć) sygnał SIGHUP?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Sygnał SIGHUP ignorujemy, ponieważ jest on wysyłany do wszystkich potomków po zamknięciu przywódcy sesji.</p></li><li data-list-text="4."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Dlaczego podczas tworzenia procesu demona należy przekierować stdin,</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">stdout i stderr do /dev/null?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Zapewniamy, że podstawowe deskryptory są otwarte i użycie funkcji bibliotecznych, które z nich korzystają nie spowoduje błędu wykonania się tych funkcji lub jeśli przy zamkniętych wszystkich deskryptorach otworzymy gniazdo, to może mieć ono wartość taką, jak stdout lub stderr, co spowoduje, że funkcje biblioteczne mogą “bezwiednie” pisać do gniazda</p></li><li data-list-text="5."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do czego służy demon syslog?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Do logowania zdarzeń w systemie</p></li><li data-list-text="6."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do czego służą parametry &quot;level&quot; i &quot;facility&quot; w API do sysloga?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">level - określa poziom logowania</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">facility - typ procesu</p></li><li data-list-text="7."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">W jaki sposób w programie z poziomu API do demona syslog można wpływać</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">na miejsce, w którym zapisywane są logi?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Funkcją chroot()</p></li><li data-list-text="8."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">W jaki sposób administrator systemu może wpływać na miejsce, w którym zapisywane są logi demona syslog?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Edycja pliku konfiguracyjnego np. /etc/rsyslogd.conf</p></li><li data-list-text="9."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Co jest przechowywane w plikach /etc/hosts, /etc/networks, /etc/services,</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">/etc/protocols?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">/etc/hosts - Jest to prosty plik tekstowy, który przypisuje adresy IP nazwom komputerów,</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">każdy adres w osobnej linii.</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">/etc/networks - jest to plik opisującym znane sieci oraz ich symboliczne nazwy. Każda linia reprezentuje konkretną, znaną sieć</p><p style="padding-top: 7pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">/etc/services - przechowuje informację o serwisach działających na danych portach. Kluczowa rola tego pliku polega na tym, że programy mogą wykonywać wywołania getportbyname () w swoim kodzie, aby zrozumieć, z jakiego portu mają korzystać.</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">/etc/protocols - Plik zawiera informacje o znanych protokołach używanych w Internecie. Każdy protokół jest reprezentowany przez pojedynczy wiersz w pliku.</p></li><li data-list-text="10."><p class="s1" style="padding-top: 9pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do czego służą pliki /etc/host.conf i /etc/resolv.conf?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">/etc/host.conf - plik określający sposób ustalania nazw hostów w sieci, czyli dopasowywania ich do konkretnych adresów IP.</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">/etc/resolv.conf - plik używany do konfiguracji serwera DNS</p></li><li data-list-text="11."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Do czego służą funkcje gethostbyname() i gethostbyname2() i czym się różnią?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Funkcje te zwracają strukturę hostent, która zawiera informacje min o adresie IP, na podstawie argumentu hostname (np. www.google.com).</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Funkcja gethostbyname2 jest podobna do gethostbyname, ale umożliwia wywołującemu określenie żądanej rodziny adresów (np. AF_INET lub AF_INET6) wyniku.</p></li><li data-list-text="12."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do czego służy opcja RES_USE_INET6 ?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Służy do obsługi IPv6 w funkcji gethostbyname()</p></li><li data-list-text="13."><p class="s1" style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Do czego służą funkcje gethostbyaddr() i getnameinfo()? <span class="s7">gethostbyaddr() - funkcja odwrotna do gethostbyname, zwraca rekordy PTR z DNS, pierwotnie tylko dla IPv4</span></p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">getnameinfo() - odwrotna do gethostbyaddr, konwersja address-to-name</p></li><li data-list-text="14."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do czego służą i jakie parametry przechowują struktury hostent i servent?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Hosten - służy do przechowywania adresów IPv4 oraz adresów IPv6 oraz informacji o nich</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">struct hosten{</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">char  *h_name;   /* official name of host */</p><p style="padding-top: 4pt;padding-left: 47pt;text-indent: 0pt;text-align: justify;">char  **h_aliases;  /* alias list */</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: justify;">int   h_addrtype;  /* host address type */ int   h_legth;    /* length of address */ char  **h_addr_list; /* list of addresses */ }</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">Servent - przechowuje oraz zwraca nazwę oraz informacje dla podanej nazwy usługi</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">struct servent {</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">char  *s_name;   /* official service name */ char  **s_aliases;  /* alias list */</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">int   s_port;    /* port number */</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">char  *s_proto;   /* protocol to use */  }</p></li><li data-list-text="15."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie rekordy z usługi DNS pobierają funkcje gethostbyname(),</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">gethostbyaddr(), getaddrinfo() i getnameinfo()?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">gethostbyname() - A i AAAA gethostbyaddr() - PTR getaddrinfo() - A i AAAA getnameinfo() - PTR</p></li><li data-list-text="16."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Które funkcje w jednym wywołaniu mogą zwrócić jednocześnie rekordy A i AAAA z usługi DNS?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: justify;">gethostbyname(), gethostbyname2(), getaddrinfo(),</p></li><li data-list-text="17."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Które funkcje przekazują rekordy PTR z usługi DNS?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">gethostbyaddr()</p></li><li data-list-text="18."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie parametry należy przekazać dla funkcji getaddrinfo() dla serwera, który ma nasłuchiwać na danym porcie, tak aby bezpośrednio można było wykorzystać parametry zwracane przez funkcję getaddrinfo() w funkcji socket() i bind()?</p><ul id="l84"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Określenie flagi AI_PASSIVE w hints.ai_flags</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawienie parametru node na NULL</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawienie pramatertów dla gniazda ai_family, ai_socktype, ai_protcol, ai_addr, ai_addrlen</p></li></ul></li><li data-list-text="19."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie parametry należy przekazać dla funkcji getaddrinfo() dla klienta, który ma połączyć się na danym porcie z serwerem, tak aby bezpośrednio można było wykorzystać dane zwracane przez funkcję getaddrinfo() w funkcji socket() i connect()?</p><ul id="l85"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Flaga AI_PASSIVE nie jest określona w hints.ai_flags</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawienie pramatertów dla gniazda ai_family, ai_socktype, ai_protcol, ai_addr, ai_addrlen</p></li></ul></li><li data-list-text="20."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie parametry należy przekazać dla funkcji getaddrinfo() dla klienta, który ma połączyć się na danym porcie z serwerem na adresie loopback, tak aby bezpośrednio można było wykorzystać dane zwracane przez funkcję getaddrinfo() w funkcji socket() i connect()?</p><ul id="l86"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Flaga AI_PASSIVE nie jest określona w hints.ai_flags</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Ustawienie parametru node na NULL</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawienie pramatertów dla gniazda ai_family, ai_socktype, ai_protcol, ai_addr, ai_addrlen</p></li></ul></li></ol><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Laboratorium 9</h1><ol id="l87"><li data-list-text="1."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Do czego służy funkcja ioctl() ? Jakie parametry karty sieciowej można zmieniać za jej pomocą?</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Operacje pobrania i zmiany wartości zmiennych w jądrze z poziomu użytkownika.</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Zastosowanie:</p><ul id="l88"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Operacje na plikach</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Operacje na interfejsach sieciowych (za pomocą gniazd)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Operacje na tablicy ARP</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">Operacje na tablicach rutingu Parametry:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Zmiana metryk do trasowania w rutingu</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawianie MTU (Maximum Transmit Unit)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawianie adresu MAC</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Zmienia długość kolejki transmisyjnej</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Zmienia nazwę interfejsu</p></li></ul></li><li data-list-text="2."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie operacje można wykonywać na karcie sieciowej za pomocą funkcji</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">ioctl()?</p><ul id="l89"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawienie adresu unicast na interfejsie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Ustawienie flag na interfejsie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Ustawienie adresu broadcast</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawienie adresu point-to-point</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Ustawienie maski podsieci</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Zmiana metryk do trasowania w rutingu</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawianie MTU (Maximum Transmit Unit)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Ustawianie adresu MAC</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Zmienia długość kolejki transmisyjnej</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Zmienia nazwę interfejsu</p></li></ul></li><li data-list-text="3."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jak działa tryb PROMISCUOUS na karcie sieciowej?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">Tryb ten polega na odbieraniu całego ruchu docierającego do karty sieciowej, a nie tylko skierowanego na adres MAC karty sieciowej.</p></li><li data-list-text="4."><p class="s1" style="padding-top: 9pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Co oznacza włączenie trybu MONITOR na karcie sieciowej?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Dotyczy tylko transmisji bezprzewodowej. Pozwala na przechwytywanie wszystkich pakietów, nie tylko przeznaczonych dla tej karty sieciowej. Dodatkowo nie jest wymagane przyłączenie do danej sieci aby nasłuchiwać. W tym celu musimy stworzyć interfejs w trybie monitor.</p></li><li data-list-text="5."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie funkcje z API gniazd można użyć do wykonywania operacji na gnieździe</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">w domenie PF_PACKET?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">socket(), bind(), sendto(), recvfrom()</p></li><li data-list-text="6."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie funkcje można użyć do wysyłania pakietów dla gniazda sieciowego w</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">domenie PF_PACKET?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">sendto()</p></li><li data-list-text="7."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do czego służy opcja PACKET_ADD_MEMBERSHIP dla gniazd w domenie</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">PF_PACKET?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">PACKET_ADD_MEMBERSHIP włącza tryb PROMISCUOUS</p></li><li data-list-text="8."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie pola struktury adresowej sockaddr_ll należy obowiązkowo wypełnić wywołując funkcję bind() dla gniazda w domenie PF_PACKET?</p><ul id="l90"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sll_family</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sll_protocol</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sll_ifindex</p></li></ul></li><li data-list-text="9."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie funkcje spełnia funkcja connect() dla gniazd w domenie PF_PACKET?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Funkcja ta nie jest wspierana w domenie PF_PACKET</p></li><li data-list-text="10."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">W jaki sposób przestawić interfejs sieciowy w tryb PROMISCUOUS za pomocą</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">gniazd sieciowych? (dwa sposoby)</p><ul id="l91"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">Włączamy opcję PACKET_ADD_MEMBERSHIP.</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Poprzez funkcję ioctl() ustawiamy flagę IFF_PROMISC.</p></li></ul></li><li data-list-text="11."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie pola struktury adresowej sockaddr_ll należy wypełnić wysyłając ramkę Ethernet za pomocą gniazda PF_PACKET ?</p><ul id="l92"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sll_family,</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sll_addr</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sll_halen</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sll_ifindex</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sll_protocol</p></li></ul></li><li data-list-text="12."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby można było odebrać pakiet na gnieździe PF_PACKET?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: left;">socket()</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">bind() - opcjonalnie rcvfrom()</p></li><li data-list-text="13."><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby można było odesłać pakiet na gnieździe PF_PACKET?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: left;">socket()</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Wypełniamy strukturę sockadr_ll (konieczne pola:</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">sll_family, sll_addr, sll_halen, sll_ifindex, sll_protocol) sendto()</p></li><li data-list-text="14."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Czym rożni się gniazdo w domenie PF_PACKET typu SOCK_RAW od</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">SOCK_DGRAM?</p><ul id="l93"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">SOCK_RAW jest dla pakietów z usuniętym nagłówkiem warstwy łącza tzw „cooked”</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">SOCK_DGRAM jest dla kompletnych pakietów</p></li></ul></li></ol><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Pytania – wejściówka 5</h1><ol id="l94"><li data-list-text="1."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby wysłać pakiet na adres 255.255.255.255 dla protokołu UDP na port 21 z portu 66? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><ul id="l95"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">(za to 1 pkt)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sock()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendto()/sendmsg()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">send()+connect()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">write()+connect()</p></li></ul></li><li data-list-text="2."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby wysłać pakiet na gnieździe PF_PACKET? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><ul id="l96"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Tworzymy gniazdo:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP));</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Uzupełniamy strukturę</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Fill sockaddr_ll structure - specify sll_family, sll_protocol, sll_addr, sll_halen, sll_ifindex. The other fields should be 0.</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wysyłamy pakiet:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto(sockfd, buffer, strlen(buffer)+1, 0, (SA*)&amp;servaddr, sizeof(servaddr));</p></li></ul></li><li data-list-text="3."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie parametry należy przekazać dla funkcji getaddrinfo() dla klienta, który ma połączyć się na danym porcie z serwerem na adresie loopback, tak aby bezpośrednio można było wykorzystać dane zwracane przez funkcję getaddrinfo() w funkcji socket() i connect()?</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Hints AI_PASSIVE==false i name==NULL oraz strukturę addrinfo oraz int *node oraz const char</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">*service - nazwe usługi</p></li><li data-list-text="4."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie pola struktury adresowej sockaddr_ll należy obowiązkowo wypełnić wywołując funkcję sendto() dla gniazda w domenie PF_PACKET?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 14pt;text-align: left;">sll_family, sll_protocol, sll_addr, sll_halen, sll_ifindex</p></li><li data-list-text="5."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby odebrać pakiet na gnieździe PF_PACKET adresowany na adres typu multicast? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><ul id="l97"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Tworzymy gniazdo</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sockfd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP));</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">ustawiamy opcję na gnieździe – setsockopt(…, ADD_MEMBERSIP,…)</p></li><li data-list-text=""><p style="padding-top: 4pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">odbieramy pakiet</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">recvfrom(sockfd, buff, 512, 0, (SA*)&amp;cliaddr, &amp;length);</p></li></ul></li><li data-list-text="6."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby wysłać pakiet na adres 255.255.255.255 dla protokołu UDP na port 21 z portu 66? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><ul id="l98"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - tworzymy gniazdo niepołączone</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() - określenie adresu i wysyłanie wiadomości</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">const struct sockaddr *addr</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendmsg() - dodatkowe informacje sterujące</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">struct msghdr msg;</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">struct cmsghdr *cmsg;</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">struct in_pktinfo *pktinfo;</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">send() + connect()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">const struct sockaddr *addr;</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;line-height: 156%;text-align: left;">write() + connect() <span style=" color: #F00;">1 / 2 pkt</span></p></li></ul></li><li data-list-text="7."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie funkcje gniazdowe można użyć do operacji na gnieździe typu</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">SOCK_RAW?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Tworzenie gniazda surowego</p><ol id="l99"><li data-list-text="a)"><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Utworzenie gniazda z opcją  SOCK_RAW</p></li><li data-list-text="b)"><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sockfd = socket(AF_INET, SOCK_RAW, protocol);</p></li><li data-list-text="c)"><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">protocol -stała IPPROTO_xxxzdefiniowana w pliku &lt;netinet/in.h&gt;</p></li><li data-list-text="d)"><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Można ustawić opcję IP_HDRINCL(tylko dla IPv4)</p></li><li data-list-text="e)"><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Bind- można dowiązać adres do gniazda surowego</p></li><li data-list-text="f)"><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Można wywołać funkcję connect()</p></li></ol></li><li data-list-text="8."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby odebrać pakiet na gnieździe PF_PACKET adresowany na adres typu broadcast? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><ul id="l100"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - gniazdo surowe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvfrom(), recvmsg() - funkcje do odebrania</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">struct sockaddr *src_addr (recvfrom())</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">struct msghdr *msg (recvmsg())</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">struct cmsghdr()</p><p class="s12" style="padding-top: 8pt;padding-left: 110pt;text-indent: 0pt;text-align: left;">1 / 2 pkt</p></li></ul></li><li data-list-text="9."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby wysłać pakiet na adres fc00:1::21 dla protokołu UDP na port 11? Opisz podstawowe funkcje, co wywoływane funkcje wykonują, najważniejsze struktury danych.</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">socket(), - funkcja tworząca gniazdo</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">bind(), - przypisanie adresu i portu gniazda sendto()/sendmsg(), - przekazywanie danych send()+connect(),</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">write()+connect()</p></li><li data-list-text="10."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby wysłać pakiet na adres fc00:1::21 dla protokołu UDP na port 11 z portu 22? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd.</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">socket():</p><ul id="l101"><li data-list-text="-"><p style="padding-left: 17pt;text-indent: -6pt;text-align: left;">utworzenie gniazda</p></li><li data-list-text="-"><p style="padding-left: 17pt;text-indent: -6pt;text-align: left;">przyjmuje: rodzinę protokołów (AF_INET6); typ gniazda(SOCK_DGRAM); typ protokołu (UDP)</p></li><li data-list-text="-"><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">zwraca: File descriptor utworzonego gniazda bind():</p></li><li data-list-text="-"><p style="padding-left: 17pt;text-indent: -6pt;line-height: 14pt;text-align: left;">przypisuje adres podany w strukturze adresowej do gniazda określonego w deskryptorze</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">pliku</p></li><li data-list-text="-"><p style="padding-left: 17pt;text-indent: -6pt;text-align: left;">jako argument przyjmuje: File Descriptor gniazda; strukturę adresową (port 22); rozmiar</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">struktury adresowej</p></li><li data-list-text="-"><p style="padding-left: 17pt;text-indent: -6pt;text-align: left;">zwraca 0 w przypadku sukcesu sendto() / sendmsg():</p></li><li data-list-text="-"><p style="padding-left: 17pt;text-indent: -6pt;text-align: left;">służy do wysłania określonego datagramu na wskazany adres</p></li><li data-list-text="-"><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">przyjmuje: File Descriptor; wskaźnik na bufor, zawierający dane do przesłania; rozmiar bufora; flagi; wskaźnik na strukturę adresową, zawierającą adres nadawcy (adres IP fc00:1::21</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">+ port 11); rozmiar tej struktury. (W przypadku sendmsg() zamiast buforów i ich długości, funkcja jako argument przyjmuje wskaźnik na strukturę msghdr, zawierającą parametry nagłówka oraz dane do przesłania)</p></li><li data-list-text="-"><p style="padding-left: 17pt;text-indent: -6pt;line-height: 15pt;text-align: left;">zwraca liczbę przesłanych bajtów</p><p class="s12" style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">2 / 2 pkt</p></li></ul></li><li data-list-text="11."><p class="s1" style="padding-top: 12pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie funkcje sieciowe należy wywołać po stronie serwera, aby odebrać pakiet od klienta dla protokołu UDP na porcie 123. Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><ul id="l102"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket()-tworzenie gniazda udp datagram</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">wypelnienie struktury adresowej</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind()-dowiazanie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">recvfrom()</p></li></ul></li><li data-list-text="12."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: justify;">Jakie kroki należy wykonać w programie, aby odebrać pakiet na gnieździe PF_PACKET? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd.</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: justify;">a) socket():</p><ul id="l103"><li data-list-text="-"><p style="padding-left: 17pt;text-indent: -6pt;text-align: justify;">utworzenie gniazda surowego</p></li><li data-list-text="-"><p style="padding-left: 17pt;text-indent: -6pt;text-align: justify;">przyjmuje: rodzinę protokołów (PF_PACKET); typ gniazda(SOCK_RAW); typ protokołu</p></li><li data-list-text="-"><p style="padding-left: 17pt;text-indent: -6pt;text-align: justify;">zwraca: File descriptor utworzonego gniazda</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: justify;">c) recvfrom()</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: justify;">-Służy do odbierania pakietów oraz identyfikowania ich nadawcy</p></li><li data-list-text="-"><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">przyjmuje: File Descriptor, wskaźnik na bufor, do którego mają zostać zapisane odebrane dane; rozmiar bufora; flagi; wskaźnik na strukturę adresową, do której powinien zostać zapisany adres nadawcy (adres typu broadcast); rozmiar tej struktury</p></li><li data-list-text="-"><p style="padding-left: 17pt;text-indent: -6pt;text-align: left;">zwraca liczbę odebranych bajtów</p></li></ul><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">(alternatywnie: recvmsg() - pozwala odczytać dodatkowe opcje z nagłówka)</p></li><li data-list-text="13."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby odebrać pakiet adresowany na adres ff02:1::1:1 na port 345? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, możliwy typ adresacji, wymagane typy gniazd.</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">socket()-tworzymy gniazdo niepołączone</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Ustawiamy opcje (obowiązkowe) – setsockopt(…, ADD_MEMBERSIP,…)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">bind()-przekazanie numeru portu do tej funkcji</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">recvfrom()/recvmsg()-funkcje odbierające, zwracają adresy nadawcy a do tego recvmsg() odczytuje opcje z nagłówka IP</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Struktury:</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">struct sockaddr *src_addr(recvfrom()) struct msghdr *msg(recvmsg())</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">struct cmsghdr</p></li><li data-list-text="14."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Do czego służy funkcja ioctl()</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: justify;">Funkcja ioctl() służy do sterowania urządzeniami. Pobiera i zmienia wartości zmiennych w jądrze z poziomu użytkownika. Wykorzystywana jest w operacjach na plikach, interfejsach, tablicach routingu i operacjach na tablicy ARP</p><p class="s12" style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">(1.5/2pkt)</p></li><li data-list-text="15."><p class="s1" style="padding-top: 12pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie operacje można wykonywać na karcie sieciowej za pomocą funkcji</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">ioctl()?</p></li><li data-list-text="16."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie funkcje sieciowe należy wywołać po stronie serwera, aby odebrać pakiet od klienta dla protokołu SCTP na porcie 123 w trybie ‘one-to-one’. Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="17."><p class="s1" style="padding-top: 14pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jak można filtrować pakiety, które są odbierane na gnieździe surowym, z poziomu programu z użyciem API gniazd sieciowych, bez użycia API do mechanizmu iptables?</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">opcja ICMP_FILTER ?</p><p style="padding-top: 10pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Jest możliwość filtrowania za pomocą gniazd i ich opcji, np. funkcje icmp6_filter</p></li><li data-list-text="18."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby wysłać pakiet z użyciem gniazda PF_PACKET na adres typu broadcast? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">zdefiniować strukturę sockaddr_ll i ją wypełnić (pole sll_family, sll_ifindex, sll_protocol, sll_halen i wpisać adres broadcast w pole sll_addr)</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">utworzyć gniazdo - socket()</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">wysłać dane funkcją sendto()</p></li><li data-list-text="19."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Opisz krótko proces zamykania asocjacji dla protokolu SCTP w trybie</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">„one-to-one”:</p><ul id="l104"><li data-list-text=""><p style="padding-top: 1pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">aktywne zamykanie-shutdown()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">druga strona shutdownack</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">poprzednia shutdown complete</p></li></ul></li><li data-list-text="20."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki nalezy wykonac w programie, aby wyslac pakiet na adres fc00:1::21 dla protokolu SCTP na port 11 z portu 22, jednoczesnie nie akceptujac nowych asocjacji? Opisz podstawowe funkcje sieciowe, co wywolywane funkcje wykonuja, najwazniejsze struktury danych, wymagane typy gniazd, typ adresacji:</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">{??}, funkcje jak tcp one-to-one socket()</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">wypelnienie struktury adresowej connect()</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">write()</p></li><li data-list-text="21."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki nalezy wykonac w programie, aby mozna bylo odebrac pakiet adresowany na adres 224.1.1.1 na port 567? Opisz podstawowe funkcje, co wywolywane funkcje wykonuja, najwazniejsze struktury danych.:multicast</p><ul id="l105"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">musmy stworzyc gniazdo socket()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">wypelnic strukture adresowa</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">musimy dolaczyc sie do grupy mulitastowej setsockopt</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind()-powiazanie do portu</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">i przygotowac sie na odbior danych przez recvfrom</p></li></ul></li><li data-list-text="22."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie funkcje sieciowe należy wywołać po stronie serwera, aby odebrać pakiet od klienta dla protokołu UDP na porcie 123. Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><ul id="l106"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - utworzenie gniazda , setsockopt : SOCK_DGRAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - dowiazanie gniazda, w argumentach podac port 123</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">read()/recvfrom()/recvmsg() - odbieranie wiadomosci</p></li></ul></li><li data-list-text="23."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jak działa tryb PROMISCUOUS ustawiony na karcie sieciowej? 1,5/2</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">Jak jest on ustawiony na karcie sieciowej to odbieramy cały ruch sieciowy który przychodzi na karte sieciową ( a nie tylko ten skierowany konkretnie do niej, na jej adres MAC)</p></li><li data-list-text="24."><p class="s1" style="padding-top: 9pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w porogramie, aby wysłać pakiet z użyciem gniazda PF_PACKET na adres typu multicast? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd. – 1,5/2</p><ul id="l107"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL) - utworzenie gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() i wypełnić servaddr.sll_family = AF_PACKET, servaddr.sll_protocol = htons(ETH_P_ALL), servaddr.sll_ifindex(if_idx), servaddr.sll_pkttype = PACKET_MULTICAST - dowiązanie gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendto() - wysłanie wiadomości</p></li></ul></li><li data-list-text="25."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby odebrać pakiet adresowany na adres 224.1.1.1 na port 567? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, możliwy typ adresacji. 0,5/2</p><ul id="l108"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - utworzenie gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() - dołączenie gniazda do adresu 224.1.1.1. i portu 567 (htons(567))</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">recvfrom() - odebranie wiadomości</p></li></ul></li><li data-list-text="26."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie pola struktury adresowej sockaddr_ll należy obowiązkowo wypełnić wywołując funkcję blind() dla gniazda w domenie PF_PACKET?</p></li><li data-list-text="27."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby odebrać pakiet na gnieździe PF_PACKET adresowany na adres typu multicast? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="28."><p class="s1" style="padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie funkcje sieciowe należy wywołać po stronie serwera, aby odebrać pakiet od klienta dla protokołu UDP na porcie 123. Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych wymagane typy gniazd, typ adresacji. – 1,5/2</p><ul id="l109"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - utworzenie gniazda, setsockopt: SOCK_DGRAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - dowiązanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvfrom() - odbieranie wiadomości</p></li></ul></li><li data-list-text="29."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie funkcje sieciowe należy wywołać po stronie serwera, aby odebrać pakiet od klienta dla protokołu SCTP na porcie 123 w trybie ‘one-to-one’. Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd, typ adresacji. 1/2</p><ul id="l110"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - utworzenie gniazda niepołączonego</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() – dowiązanie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">listen() - zmienia stan gniazda na pasywne</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept() - zwraca gniazdo połączone oraz adres połączenia</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">read() - czytanie z deskryptora</p></li></ul></li><li data-list-text="30."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie kroki należy wykonać w programie, aby wysłać pakiet z użyciem gniazda PF_PACKET na adres typu multicast? Opisz podstawowe funkcje sieciowe, co wywoływane funkcje wykonują, najważniejsze struktury danych, wymagane typy gniazd. – 1,5/2</p><ul id="l111"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - utworzenie gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie wiadomości</p></li></ul></li></ol><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Laboratorium 10</h1><ol id="l112"><li data-list-text="1."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jakie główne kroki należy wykonać w programie korzystającym z biblioteki libpcap do podglądnięcia zawartości pakietu?</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">pcap_init() pcap_create() pcap_activate()</p></li><li data-list-text="2."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jaki parametr interfejsu należy znać, aby otworzyć interfejs za pomocą API</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">biblioteki libpcap?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Niezbędna jest nazwa interfejsu</p></li><li data-list-text="3."><p class="s1" style="padding-top: 11pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Czym różni się funkcja pcap_open_live() od funkcji pcap_create()? <span class="s7">pcap_open_live() służy do uzyskania handlera przechwytywania pakietów w celu przeglądania pakietów w sieci. urządzenie to ciąg określający urządzenie sieciowe do otwarcia; w systemach Linux z jądrem 2.2 lub nowszym argument urządzenia &quot;any&quot; lub NULL może być użyty do przechwytywania pakietów ze wszystkich interfejsów.</span></p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">pcap_create() służy do tworzenia uchwytu przechwytywania pakietów, który umożliwia przeglądanie pakietów w sieci. source to łańcuch określający urządzenie sieciowe do otwarcia; w systemach Linux z jądrem 2.2 lub nowszym, argument źródłowy &quot;any&quot; lub NULL może być użyty do przechwytywania pakietów ze wszystkich interfejsów.</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Zwrócony uchwyt musi zostać aktywowany za pomocą pcap_activate(3PCAP), zanim pakiety będą mogły zostać przechwycone za jego pomocą; opcje przechwytywania, takie jak tryb promiscuous, można ustawić na uchwycie przed jego aktywacją.</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">pcap_create() i pcap_activate() nie były dostępne w wersjach libpcap wcześniejszych niż 1.0; jeśli piszesz aplikację, która musi działać na wersjach libpcap wcześniejszych niż 1.0, użyj pcap_open_live(), aby uzyskać handler do przechwytywania na żywo,</p></li><li data-list-text="4."><p class="s1" style="padding-top: 10pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Czym różni się funkcja pcap_open_live() od funkcji pcap_open_offline()? <span class="s7">pcap_open_live() służy do uzyskania handlera przechwytywania pakietów w celu przeglądania pakietów w sieci. urządzenie to ciąg określający urządzenie sieciowe do otwarcia; w systemach Linux z jądrem 2.2 lub nowszym argument urządzenia &quot;any&quot; lub NULL może być użyty do przechwytywania pakietów ze wszystkich interfejsów.</span></p><p style="padding-top: 7pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">pcap_open_offline() i pcap_open_offline_with_tstamp_precision() są wywoływane w celu</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">otwarcia pliku zapisu do odczytu.</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">fname określa nazwę pliku do otwarcia. Plik może mieć format pliku pcap opisany w</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">pcap-savefile(5), który jest formatem używanym m.in. przez tcpdump(1) i tcpslice(1), lub może mieć format pliku pcapng, chociaż nie można odczytać wszystkie pliki pcapng. Nazwa „-” jest synonimem stdin.</p></li><li data-list-text="5."><p class="s1" style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Czym różni się funkcja pcap_open_live() od funkcji pcap_activate()? <span class="s7">pcap_open_live() służy do uzyskania uchwytu przechwytywania pakietów w celu przeglądania pakietów w sieci. urządzenie to ciąg określający urządzenie sieciowe do otwarcia; w systemach Linux z jądrem 2.2 lub nowszym argument urządzenia &quot;any&quot; lub NULL może być użyty do przechwytywania pakietów ze wszystkich interfejsów.</span></p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">pcap_activate() służy do aktywowania uchwytu przechwytywania pakietów w celu przeglądania pakietów w sieci, przy czym obowiązują opcje ustawione w uchwycie.</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">pcap_create() i pcap_activate() nie były dostępne w wersjach libpcap wcześniejszych niż 1.0; jeśli piszesz aplikację, która musi działać na wersjach libpcap wcześniejszych niż 1.0, użyj pcap_open_live(), aby uzyskać handler do przechwytywania na żywo,</p></li><li data-list-text="6."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Wymień dwa parametry, które można ustawić na uchwycie do</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">przechwytywania pakietów pcap_t w bibliotece libpcap()</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">device i snaplen ?</p></li><li data-list-text="7."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jak interpretować następujący filtr biblioteki libpcap: ip6 tcp and port 80 and tcp[13:1] &amp; 0x3 != 0</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: left;">Pokazuje tylko pakiety o adresie hosta IPv6 po TCP na porcie 80 oraz flagą TCP [13:1] oraz chuj</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">wie</p></li><li data-list-text="8."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Czym różną się funkcje pcap_dispatch() i pcap_loop()?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">pcap_dispatch - odczytuje bufor pełen pakietów z otwartego pcap_t do przechwytywania na żywo lub pełny zestaw pakietów z otwartego pcap_t do ``savefile&#39;&#39;</p><p style="padding-top: 7pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">pcap_loop - czytaj pakiety z pcap_t aż do wystąpienia przerwania lub błędu</p></li><li data-list-text="9."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie informacje przekazywane są w strukturze struct pcap_pkthdr</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">ts - struct timeval zawierający czas przechwycenia pakietu</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">caplen - a bpf_u_int32 podający liczbę bajtów pakietu dostępnych z przechwycenia</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">len - a bpf_u_int32 podający długość pakietu w bajtach (która może być większa niż liczba bajtów dostępnych z przechwycenia, jeśli długość pakietu jest większa niż maksymalna liczba bajtów do przechwycenia).</p></li><li data-list-text="10."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Czym różnią się funkcje pcap_dispatch() i pcap_next()</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">pcap_dispatch() pozwala na przetwarzanie wielu pakietów (sprecyzowane przez argument cnt), natomiat pcap_next() polega na odebraniu pojedynczego pakietu (poprzez wywyołanie pcap_dispatch() z cnt=1) i zwraca komunikat o sukcesie/błędzie</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">pcap_dispatch pozwala na przetwarzanie wielu pakietów (sprecyzowane przez argument cnt)</p></li><li data-list-text="11."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Czym różni się gniazdo typu SOCK_RAW od gniazda SOCK_DGARM i SOCK</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">_STREAM?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">SOCK_STEAM i SOCK_DGRAM wymagają, by pakiety były stworzone w konwencji protokołu IP, umożliwiając odbiór strumienia danych. SOCK_RAW natomiast daje większą elastyczność i pozwala nam na implementowanie własnych protokołów i struktur dzięki przesyłaniu surowych danych.</p></li><li data-list-text="12."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie funkcje gniazdowe można użyć do gniazd typu SOCK_RAW?</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Można używać sendto() lub sendmsg(), write() i send() pod warunkiem że wcześniej użyjemy</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">funkcji connect.</p><p style="padding-top: 9pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Oprócz tego setsockopt() i getsockopt() jeśli użyjemy flagi IPPROTO_RAW.</p></li><li data-list-text="13."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jeśli ustawiono opcję IP_HDRINCL, to jakie pola nie muszą być wypełniane w nagłówku IP:</p><ol id="l113"><li data-list-text="a)"><p style="padding-top: 2pt;padding-left: 11pt;text-indent: 18pt;line-height: 111%;text-align: left;">w systemach typu UNIX Source address, packet Id</p></li><li data-list-text="b)"><p style="padding-top: 10pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">w systemie LINUX</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Packet Id i Source Address, Pole identyfikacji oraz suma kontrolna - mogą być wyliczone automatycznie przez jądro</p></li></ol></li><li data-list-text="14."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie są różnice przy wysyłaniu pakietów typu SOCK_RAW dla protokołów</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">IPv4 i IPv6.</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: justify;">Przeciwnie do IPv4, przy odebraniu pakietu IPv6 jądro zawsze tworzy nagłówek IPv6. Z racji że w IPv6 nie ma możliwości ustawienia opcji IP_HDRINCL - gdy chcemy więc dokonywać zmian przy nagłówku IPv6, musimy używać funkcji edycji opcji gniazd setsockopt().</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Liczenie sum kontrolnych dla pakietów IPv6 odbywa się automatycznie, możemy jednak sprecyzować czy jądro ma obliczać sumę kontrolną dla gniazd utworzonych z trzecim argumentem innym od IPPROTO_ICMPV6. Dla IPv4 proces sam musi obliczać sumę kontrolną</p></li><li data-list-text="15."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakie są różnice przy odbieraniu pakietów typu SOCK_RAW dla protokołów</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">IPv4 i IPv6.</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: justify;">Przeciwnie do IPv4, przy odebraniu pakietu IPv6 jądro zawsze tworzy nagłówek IPv6. Z racji że w IPv6 nie ma możliwości ustawienia opcji IP_HDRINCL - gdy chcemy więc dokonywać zmian przy nagłówku IPv6, musimy używać funkcji edycji opcji gniazd setsockopt().</p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Liczenie sum kontrolnych dla pakietów IPv6 odbywa się automatycznie, możemy jednak sprecyzować czy jądro ma obliczać sumę kontrolną dla gniazd utworzonych z trzecim argumentem innym od IPPROTO_ICMPV6. Dla IPv4 proces sam musi obliczać sumę kontrolną</p></li><li data-list-text="16."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakiego typu pakiety są zawsze przekazywane do gniazda surowego w</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">systemie typu UNIX</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 112%;text-align: left;">Wszystkie pakiety IGMP są przekazywane do gniazda surowego, jak również pakiety IP, których protokół nie jest zrozumiany przez jądro (chuj wie co za różnica między UNIX/LINUX)</p></li><li data-list-text="17."><p class="s1" style="padding-top: 9pt;padding-left: 29pt;text-indent: -18pt;text-align: left;">Jakiego typu pakiety są zawsze przekazywane do gniazda surowego w</p><p class="s1" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: left;">systemie LINUX</p><p style="padding-top: 1pt;padding-left: 11pt;text-indent: 0pt;line-height: 111%;text-align: left;">Wszystkie pakiety IGMP są przekazywane do gniazda surowego, jak również pakiety IP, których protokół nie jest zrozumiany przez jądro</p></li><li data-list-text="18."><p class="s1" style="padding-top: 10pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jak można filtrować pakiety, które są odbierane na gnieździe surowym, z poziomu programu bez użycia API do iptables?</p></li></ol><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">opcja ICMP_FILTER</p><h1 style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Otwarte</h1><ol id="l114"><li data-list-text="1."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi ECHO działającej na porcie 104 dla IPv6 z użyciem gniazd typu sekwencyjnego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Może wystąpić sygnał SIGCHLD który należy obsłużyć lub jawnie zignorować</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l115"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 104 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, SOCK_SEQPACK oraz protkół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 104 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 104, hints.af_family = AF_inet6, hints.socktype = sock_seqpack // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda, SOCK_SEQPACK oraz protokół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">fork() - podział na rodzica i potomka</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">close() - zamknięcie połączenia</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Zabezpieczenie: SOCK_SEQPACK zabezpiecza przed utratą pakietów</p></li></ul></li><li data-list-text="2."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi ECHO działającej na porcie 111 dla IPv4. Program serwera powinien korzystać z jednego gniazda nasłuchującego i umożliwiać dla klientów z parzystym ostatnim bajtem adresu IP obsługę w sposób iteracyjny, natomiast dla klientów z nieparzystym ostatnim bajtem adresu IP obsługę w sposób współbieżny. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji (jednym lub więcej). (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Język PYTHON TCP - niezawodny Klient :</p><ul id="l116"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">s.connect((&lt;adressipv4 serwera&gt;, 111))</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">s.send(b&#39;Hello, world&#39;)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">data = s.recv(1024)</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">s.close() Serwer :</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR,1)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">s.bind((&lt;adresipv4&gt;, 111))</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">s.listen(1)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">whileTrue:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">conn, addr = s.accept()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">print(&#39;Connected by&#39;, addr)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">data = conn.recv(1024)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">conn.send(data)</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">conn.close()</p></li></ul></li><li data-list-text="3."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi typu ECHO działającej na gniazdach z rodziny PF_PACKET. Serwer powinien nasłuchiwać na wszystkich interfejsach sieciowych stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy w programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l117"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury adresowe sockaddr_II</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury adresowej sockaddr_ll</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą ramek</p></li></ul></li><li data-list-text="4."><p class="s1" style="padding-top: 11pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi ECHO działającej na porcie 128 dla IPv6 z użyciem gniazd typu datagramowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">UDP -zawodny Klient:</p><ul id="l118"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 128 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - ustawić SOCK_DGRAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() - połączenie portu z strukturą adresową</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">recvfrom() - odebranie informacji od serwera Serwer</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 126 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-top: 4pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null, service = 128,</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">hints.af_family = AF_inet6, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - ustawić SOCK_DGRAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvfrom() - odebranie informacji</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą bramek</p></li></ul></li><li data-list-text="5."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi typu ECHO działającej na gniazdach z rodziny PF_PACKET i obsługujących adresację typu broadcast. Serwer powinien nasłuchiwać na wszystkich interfejsach sieciowych stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy w programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l119"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sll_pkttype w strukturze sockaddr_II ustawić na PACKET_BROADCAST</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_BROADCAST</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">setsockopt() - ustawić SO_BROADCAST</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą ramek</p></li></ul></li><li data-list-text="6."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi ECHO działającej na porcie 112 dla IPv6. Program serwera powinien korzystać z jednego gniazda nasłuchującego i umożliwiać dla klientów z parzystym ostatnim bajtem adresu IP obsługę w sposób iteracyjny, natomiast dla klientów z nieparzystym ostatnim bajtem adresu IP obsługę w sposób współbieżny. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Zarys: Należy stworzyć połączenie typu one-to-many, gdzie serwer na jednym gnieździe będzie korzystając z wielu asocjacji jednocześnie obsługiwał iteracyjnie klientów z bajtem parzystym i współbieżnie klientów z nieparzystym bajtem. Sprawdzanie ostatniego bajtu IP klienta można zrealizować za pomocą instrukcji warunkowej “if” w serwerze.</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Może wystąpić sygnał SIGCHLD który należy obsłużyć lub jawnie zignorować</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l120"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 112 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, SOCK_STREAM oraz protkół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 112 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 112, hints.af_family = AF_inet6, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda, SOCK_STREAM oraz protokół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">if - sprawdzanie parzystości ostatniego bajtu ip klienta</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">fork() - podział na rodzica i potomka</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">close() - zamknięcie połączenia</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Zabezpieczenie: SOCK_STREAM zabezpiecza przed utratą pakietów</p></li></ul></li><li data-list-text="7."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi DAYTIME działającej na porcie 116 dla IPv6 z użyciem gniazd typu datagramowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">UDP - zawodny Klient:</p><ul id="l121"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 116 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - ustawić SOCK_DGRAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() - połączenie portu z strukturą adresową</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">recvfrom() - odebranie informacji ode serwera Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 116 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null, service = 116,</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">hints.af_family = AF_inet6, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - ustawić SOCK_DGRAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvfrom() - odebranie informacji</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą bramek</p></li></ul></li><li data-list-text="8."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi DAYTIME działającej na porcie 136 dla IPv6 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">TCP - niezawodny</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Może wystąpić sygnał SIGCHLD, który należy obsłużyć lub jawnie zignorować</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l122"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 136 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-top: 4pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">connect()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">read() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 136 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 136, hints.af_family = AF_inet6, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">listen() - nasłuchiwanie na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">fork() - podział na proces potomka i rodzica</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">close()</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">ODP: jest zabezpieczenie przed utratą pakietów (TCP)</p></li></ul></li><li data-list-text="9."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi DAYTIME działającej na porcie 131 dla IPv4 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">TCP - niezawodny</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Może wystąpić sygnał SIGCHLD, który należy obsłużyć lub jawnie zignorować</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l123"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 131 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">connect()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">read() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 131 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 131, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-top: 4pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">listen() - nasłuchiwanie na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">fork() - podział na proces potomka i rodzica</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">close()</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">ODP: jest zabezpieczenie przed utratą pakietów (TCP)</p></li></ul></li><li data-list-text="10."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi DAYTIME działającej na porcie 116 dla IPv6. Program serwera powinien korzystać z jednego gniazda, z którego jest możliwość także inicjowania nowych połączeń. Klient nie powinien mieć możliwości odbierania pakietów dla połączeń, które nie zestawił. Wybierz odpowiedni protokół transportowy: UDP, TCP lub SCTP. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny Klient:</p><ul id="l124"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 116 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, protkół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 116 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 116, hints.af_family = AF_inet6, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda, protokół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul></li><li data-list-text="11."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi DAYTIME działającej na porcie 122 dla IPv6, obsługującej adresację typu multicast. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">UDP - zawodny Serwer:</p><ul id="l125"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Dowiązuje hosta do grupy multicastowej</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 122 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawić opcję multicast</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() - powiązanie portu ze strukturą</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie wiadomości do gniazda</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Należy poprosić serwer o dowiązanie do grupy multicastowej</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 122 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null,</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">service = 122,</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">hints.af_family = AF_inet6, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawić opcję multicast</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvfrom() - otrzymanie wiadomości z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">close() - zamknięcie gniazda</p></li></ul></li><li data-list-text="12."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi DAYTIME działającej na porcie 102 dla IPv4 z użyciem gniazd typu sekwencyjnego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny Klient:</p><ul id="l126"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 102 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-top: 4pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, SOCK_SEQPACK oraz protkół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 102 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 102, hints.af_family = AF_inet, hints.socktype = sock_seqpack // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda, SOCK_SEQPACK oraz protokół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">close() - zamknięcie połączenia</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Zabezpieczenie: SOCK_SEQPACK zabezpiecza przed utratą pakietów</p></li></ul></li><li data-list-text="13."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi ECHO działającej na porcie 124 dla IPv6 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">TCP - niezwodny Serwer:</p><ul id="l127"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Musimy obsługiwać sygnał SIGCHLD. W przeciwnym razie będą powstawać Zombie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 124 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 124, hints.af_family = AF_inet6, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket(AF_INET6, SOCK_STREAM, 0)) /dla adresów IPv6, typ strumieniowy</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt(...,...,SO_REUSEADDR) - może to pomoże z nasłuchiwaniem na wszystkich</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">adresach stacji</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">listen() - nasłuchiwanie na porcie --&gt; jak zrobić nasłuchiwanie wszędzie, na wszystkich</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">adresach</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">stacji?</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">signal(SIGCHLD, sig_chld); → w handlerze funkcją waitpid() zabijamy zakończone</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">procesy potomka</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">accept()</p></li><li data-list-text=""><p style="padding-top: 4pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">fork() - podział na proces potomka i rodzica</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">close() Klient:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 124 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">connect()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">read() - czytanie z gniazda</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">ODP: jest zabezpieczenie przed utratą pakietów (TCP)</p></li></ul></li><li data-list-text="14."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi typu ECHO działającej na gniazdach z rodziny PF_PACKET i obsługujących adresację typu multicast. Serwer powinien nasłuchiwać na wybranym interfejsie sieciowym stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy w programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Należy stworzyć grupę multicastową i dowiązywać do niej zainteresowane hosty</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Serwer:</p><ul id="l128"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket(PF_PACKET, SOCK_DGRAM, protokół) - stworzenie gniazda PF_PACKET</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">setsockopt(PACKET_MR_MULTICAST) z wypełnioną strukturą packer_mreq ustawioną na konkretną</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">grupę multicastową</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">recvmsg() - oczekiwanie na zapytanie od klienta i zebranie adresu klienta ze struktury sockaddr_II</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendmsg() - odesłanie informacji do klienta</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket(PF_PACKET, SOCK_DGRAM, protokół) - stworzenie gniazda PF_PACKET</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">setsockopt(PACKET_MR_MULTICAST) z wypełnioną strukturą packer_mreq ustawioną na konkretną</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">grupę multicastową</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">wypełnienie struktury sockaddr_in z adresem i portem serwera.</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendmsg() - wysłanie zapytania do serwera</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvmsg() - oczekiwanie na odpowiedź od serwera</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">ODP: Nie ma zabezpieczenia. SOCK_DGRAM, PF_PACKET - usługa bezpołączeniowa</p></li></ul></li><li data-list-text="15."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi DAYTIME działającej na porcie 118 dla IPv6 z użyciem gniazd typu datagramowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">UDP -zawodny Klient:</p><ul id="l129"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 118 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - ustawić SOCK_DGRAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() - połączenie portu z strukturą adresową</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">recvfrom() - odebranie informacji od serwera Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 118 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null,</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">service = 118,</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">hints.af_family = AF_inet6, hints.socktype = sock_dgram// Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - ustawić SOCK_DGRAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvfrom() - odebranie informacji</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą bramek</p></li></ul></li><li data-list-text="16."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi ECHO działającej na porcie 103 dla IPv6 z użyciem gniazd typu sekwencyjnego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 15pt;text-align: left;">SCTP - niezawodny</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Może wystąpić sygnał SIGCHLD który należy obsłużyć lub jawnie zignorować</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l130"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 130 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, SOCK_SEQPACK oraz protkół SCTP</p></li><li data-list-text=""><p style="padding-top: 4pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 103 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 103, hints.af_family = AF_inet6, hints.socktype = sock_seqpack // Z</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda, SOCK_SEQPACK oraz protokół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">fork() - podział na rodzica i potomka</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">close() - zamknięcie połączenia</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Zabezpieczenie: SOCK_SEQPACK zabezpiecza przed utratą pakietów</p></li></ul></li><li data-list-text="17."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi ECHO działającej na porcie 123 dla IPv4 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Serwer:</p><ul id="l131"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Musimy obsługiwać sygnał SIGCHLD. W przeciwnym razie będą powstawać Zombie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 123 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 123, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket(AF_INET, SOCK_STREAM, 0)) /dla adresów IPv6, typ strumieniowy</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">setsockopt(...,...,SO_REUSEADDR) - może to pomoże z nasłuchiwaniem na wszystkich</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">adresach stacji</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">listen() - nasłuchiwanie na porcie -&gt; jak zrobić nasłuchiwanie wszędzie, na wszystkich</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">adresach stacji?</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">signal(SIGCHLD, sig_chld); → w handlerze funkcją waitpid() zabijamy zakończone</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">procesy potomka</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">accept()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">fork() - podział na proces potomka i rodzica</p></li><li data-list-text=""><p style="padding-top: 4pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">close() Klient:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 124 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">connect()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">ODP: Jest zabezpieczenie przed utratą pakietów (TCP)</p></li></ul></li><li data-list-text="18."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi DAYTIME działającej na porcie 125 dla IPv4 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">TCP - niezawodny Klient:</p><ul id="l132"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 125 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">connect()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">read() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 125 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 125, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">listen() - nasłuchiwanie na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">close()</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">ODP: jest zabezpieczenie przed utratą pakietów (TCP)</p></li></ul></li><li data-list-text="19."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi DAYTIME działającej na porcie 109 dla IPv4. Program serwera powinien korzystać z jednego gniazda nasłuchującego i umożliwiać dla klientów z parzystym ostatnim bajtem adresu IP obsługę w sposób iteracyjny, natomiast dla klientów z nieparzystym ostatnim bajtem adresu IP obsługę w sposób współbieżny. Wybierz odpowiedni protokół transportowy: UDP, TCP lub SCTP. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji (jednym lub więcej). (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Zarys: Należy stworzyć połączenie typu one-to-many, gdzie serwer na jednym gnieździe będzie korzystając z wielu asocjacji jednocześnie obsługiwał iteracyjnie klientów z bajtem parzystym i współbieżnie klientów z nieparzystym bajtem. Sprawdzanie ostatniego bajtu IP klienta można zrealizować za pomocą instrukcji warunkowej “if” w serwerze.</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Może wystąpić sygnał SIGCHLD który należy obsłużyć lub jawnie zignorować</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l133"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 109 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, SOCK_STREAM oraz protkół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 109 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 109, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda, SOCK_STREAM oraz protokół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">if - sprawdzanie parzystości ostatniego bajtu ip klienta</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">fork() - podział na rodzica i potomka</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">close() - zamknięcie połączenia</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Zabezpieczenie: SOCK_STREAM zabezpiecza przed utratą pakietów</p></li></ul></li><li data-list-text="20."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi ECHO działającej na porcie 128 dla IPv6 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Serwer:</p><ul id="l134"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Musimy obsługiwać sygnał SIGCHLD albo jawnie zignorować. W przeciwnym razie będą powstawać Zombie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 128 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 125, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">signal(SIGCHLD, sig_chld); → w handlerze funkcją waitpid() zabijamy zakończone</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">procesy potomka</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() - połączenie portu z strukturą adresową</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">listen()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept z forkiem()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie nowego gniazda tcp dla dziecka</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">recv()</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">send() Klient:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 128 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket(), tak jak w serwerze</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">connect()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">send()</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">recv()</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">ODP: NIE PONIEWAŻ TCP</p></li></ul></li><li data-list-text="21."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi typu DAYTIME działającej na gniazdach z rodziny PF_PACKET i obsługujących adresację typu broadcast. Serwer powinien nasłuchiwać na wybranym interfejsie sieciowym stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy w programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l135"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sll_pkttype w strukturze sockaddr_II ustawić na PACKET_BROADCAST</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_BROADCAST</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_BROADCAST</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą ramek</p></li></ul></li><li data-list-text="22."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Jak zrealizowałbyś program serwera współbieżnego dla usługi typu DAYTIME działającej na gniazdach z rodziny PF_PACKET. Jakie ograniczenia w liczbie obsługiwanych klientów będą obowiązywać. (Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy w programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l136"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_BROADCAST</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_BROADCAST</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text=""><p style="padding-top: 4pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą ramek</p></li></ul></li><li data-list-text="23."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi ECHO działającej na porcie 131 dla IPv6, obsługującej adresację typu multicast. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">UDP - zawodny Serwer:</p><ul id="l137"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Dowiązuje hosta do grupy multicastowej</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 131 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 131, hints.af_family = AF_inet6, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Ustawić opcję multicast</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - powiązanie portu ze strukturą</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvfrom() - otrzymanie wiadomości z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie wiadomości do gniazda</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Należy poprosić serwer o dowiązanie do grupy multicastowej</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 131 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Ustawić opcję multicast</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie wiadomości do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvfrom() - otrzymanie wiadomości z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">close() - zamknięcie gniazda</p></li></ul></li><li data-list-text="24."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi ECHO działającej na porcie 113 dla IPv4. Program serwera powinien korzystać z jednego gniazda, z którego jest możliwość także inicjowania nowych połączeń. Klient nie powinien mieć możliwości odbierania pakietów dla połączeń, które nie zestawił. Wybierz odpowiedni protokół transportowy: UDP, TCP lub SCTP. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny Klient:</p><ul id="l138"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 133 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, protkół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 113 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 113, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda, protokół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul></li><li data-list-text="25."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi DAYTIME działającej na porcie 135 dla IPv4 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">W serwerze może wystąpić sygnał SIGCHLD, który należy obsłużyć lub jawnie zignorować</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">TCP - niezawodny Klient:</p><ul id="l139"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 135 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazd, Ustawić SOCK_STREAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">read() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 135 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 135, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda,Ustawić SOCK_STREAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">fork() - podział na proces rodzica i potomka</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul></li><li data-list-text="26."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi ECHO działającej na porcie 134, obsługującej adresację typu broadcast. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wszystkich adresach IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">UDP - zawodne</p><p style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l140"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 134 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, SOCK_DGRAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() - połączeni portu z strukturą adresową</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">rcvfrom() - odebranie informacji ode serwera Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 134 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null,</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">service = 134,</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">hints.af_family = AF_inet, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, SOCK_DGRAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawienie opcji SO_BROADCAST</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">rcvfrom() - odebranie informacji</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie informacji</p></li></ul></li><li data-list-text="27."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi typu ECHO działającej na gniazdach z rodziny AF_INET6 typu RAW. Serwer powinien nasłuchiwać na wybranym adresie sieciowym stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy w programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Serwer:</p><ul id="l141"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury adresowej sockaddr_in6</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda z opcją gniazd surowych IPPROTO_RAW i rodziną gniazd</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">AF_INET6</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - połączenie portu z strukturą adresową</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">listen() - ustawienie nasłuchiwania</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">recv() - odebranie danych od klienta</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sendto() - wysłanie danych do gniazda surowego</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">close() - zamknięcie gniazda</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury adresowej sockaddr_in6</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda z opcją gniazd surowych IPPROTO_RAW i rodziną gniazd</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">AF_INET6</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">connect() - połączenie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie danych</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">recv() - odebranie danych</p></li></ul></li><li data-list-text="28."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi DAYTIME działającej na porcie 115 dla IPv4. Program serwera powinien korzystać z jednego gniazda, z którego jest możliwość także inicjowania nowych połączeń. Klient nie powinien mieć możliwości odbierania pakietów dla połączeń, które nie zestawił. Wybierz odpowiedni protokół transportowy: UDP, TCP lub SCTP. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny Klient:</p><ul id="l142"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 115 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, protkół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 115 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 115, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda, protokół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li></ul></li><li data-list-text="29."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi ECHO działającej na porcie 133, obsługującej adresację typu broadcast. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">UDP - zawodny</p><p style="padding-top: 4pt;padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l143"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 133 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Socket() – stworzenie gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Setsockopt() – użyjemy do ustawienia opcji SO_BROADCAST</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Sendto() – wysłanie na broadcast</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">Recvfrom() – odebranie informacji Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 133 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null,</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">service = 133,</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">hints.af_family = AF_inet, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Socket() – stworzenie gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Bind() – połączenia portu ze strukturą danych</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Recvfrom() – otrzymanie informacji</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Sendto() – wysłanie informacji</p></li></ul></li><li data-list-text="30."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi ECHO działającej na porcie 129 dla IPv4 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny Klient:</p><ul id="l144"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 129 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, protkół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 129 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 129, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda, protokół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-top: 4pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul></li><li data-list-text="31."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi DAYTIME działającej na porcie 123, obsługującej adresację typu broadcast. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">UDP - zawodny Klient:</p><ul id="l145"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 123 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Bind() - połączenie portu ze strukturą adresową</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">Recvfrom() – odebranie informacji od serwera Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 123 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null,</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">service = 123,</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">hints.af_family = AF_inet, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Socket() – stworzeni gniazda o typie SOCK_DGRAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnić strukture adresową sockaddr</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Setsockopt() - ustawic opcję SO_BROADCAST</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Sendto() – wysłanie informacji</p></li></ul></li><li data-list-text="32."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi ECHO działającej na porcie 108 dla IPv6. Program serwera powinien korzystać z jednego gniazda, z którego jest możliwość także inicjowania nowych połączeń. Wybierz odpowiedni protokół transportowy: UDP, TCP lub SCTP. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji (jednym lub więcej). (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny Klient:</p><ul id="l146"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 129 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, protkół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 108 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 108, hints.af_family = AF_inet6, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda, protokół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul></li><li data-list-text="33."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi typu DAYTIME działającej na gniazdach z rodziny AF_INET typu RAW. Serwer powinien nasłuchiwać na wybranym adresie sieciowym stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy w programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Serwer:</p><ul id="l147"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury adresowej sockaddr_in</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda z opcją gniazd surowych IPPROTO_RAW i rodziną gniazd</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">AF_INET</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - połączenie portu z strukturą adresową</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">listen() - ustawienie nasłuchiwania</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie danych do gniazda surowego</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">close() - zamknięcie gniazda</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury adresowej sockaddr_in</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda z opcją gniazd surowych IPPROTO_RAW i rodziną gniazd</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">AF_INET</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">connect() - połączenie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">recv() - odebranie danych</p></li></ul></li><li data-list-text="34."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi DAYTIME działającej na porcie 120 dla IPv4, obsługującej adresację typu multicast. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">UDP - zawodny Serwer:</p><ul id="l148"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Dowiązuje hosta do grupy multicastowej</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 120 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Ustawić opcję multicast</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - powiązanie portu ze strukturą</p></li><li data-list-text=""><p style="padding-top: 4pt;padding-left: 47pt;text-indent: -18pt;text-align: left;">sendto() - wysłanie wiadomości do gniazda</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Należy poprosić serwer o dowiązanie do grupy multicastowej</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 120 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null,</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">service = 120,</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">hints.af_family = AF_inet, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Ustawić opcję multicast</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">recvfrom() - otrzymanie wiadomości z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">close() - zamknięcie gniazda</p></li></ul></li><li data-list-text="35."><p class="s1" style="padding-top: 2pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi ECHO działającej na porcie 127 dla IPv4 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">W serwerze może wystąpić sygnał SIGCHLD, który należy obsłużyć lub jawnie zignorować</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">TCP - niezawodny Klient:</p><ul id="l149"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 127 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, Ustawić SOCK_STREAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">read() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 127 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 127, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Ustawić SOCK_STREAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazd, ustawić SOCK_STREAM</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">fork() - podział na proces rodzica i potomka</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul></li><li data-list-text="36."><p class="s1" style="padding-top: 4pt;padding-left: 29pt;text-indent: -18pt;line-height: 111%;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi DAYTIME działającej na porcie 110 dla IPv6. Program serwera powinien korzystać z jednego gniazda nasłuchującego i umożliwiać dla klientów z parzystym ostatnim bajtem adresu IP obsługę w sposób iteracyjny, natomiast dla klientów z nieparzystym ostatnim bajtem adresu IP obsługę w sposób współbieżny. Wybierz odpowiedni protokół transportowy: UDP, TCP lub SCTP. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji (jednym lub więcej). (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Zarys: Należy stworzyć połączenie typu one-to-many, gdzie serwer na jednym gnieździe będzie korzystając z wielu asocjacji jednocześnie obsługiwał iteracyjnie klientów z bajtem parzystym i współbieżnie klientów z nieparzystym bajtem. Sprawdzanie ostatniego bajtu IP klienta można zrealizować za pomocą instrukcji warunkowej “if” w serwerze. Może wystąpić sygnał SIGCHLD który należy obsłużyć lub jawnie zignorować</p><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l150"><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 110 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze</p><p style="padding-left: 47pt;text-indent: 0pt;text-align: left;">//Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">socket() - stworzenie gniazda, SOCK_STREAM oraz protkół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text=""><p style="padding-left: 11pt;text-indent: 18pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 110 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 110, hints.af_family = AF_inet6, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">socket() - stworzenie gniazda, SOCK_STREAM oraz protokół SCTP</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;line-height: 15pt;text-align: left;">if - sprawdzanie parzystości ostatniego bajtu ip klienta</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">fork() - podział na rodzica i potomka</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text=""><p style="padding-left: 47pt;text-indent: -18pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul></li></ol><p style="padding-left: 11pt;text-indent: 0pt;text-align: left;">Zabezpieczenie: SOCK_STREAM zabezpiecza przed utratą pakietów</p></body></html>
