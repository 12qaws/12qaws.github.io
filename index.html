<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="pl" lang="pl"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>file_1655981866666</title><meta name="author" content="Mikołaj Kozok"/><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 .s1 { color: #2E5395; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 16pt; }
 .s2 { color: #2E5395; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s3 { color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .p, p { color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; margin:0pt; }
 .s4 { color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s5 { color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s6 { color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s7 { color: #2E5395; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 .s8 { color: #1F3762; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 12pt; }
 li {display: block; }
 #l1 {padding-left: 0pt;counter-reset: c1 1; }
 #l1> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)". "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l1> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 #l2 {padding-left: 0pt; }
 #l2> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l3 {padding-left: 0pt; }
 #l3> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l4 {padding-left: 0pt; }
 #l4> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l5 {padding-left: 0pt; }
 #l5> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l6 {padding-left: 0pt; }
 #l6> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l7 {padding-left: 0pt; }
 #l7> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l8 {padding-left: 0pt; }
 #l8> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l9 {padding-left: 0pt; }
 #l9> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l10 {padding-left: 0pt; }
 #l10> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l11 {padding-left: 0pt; }
 #l11> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l12 {padding-left: 0pt; }
 #l12> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l13 {padding-left: 0pt; }
 #l13> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l14 {padding-left: 0pt; }
 #l14> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l15 {padding-left: 0pt; }
 #l15> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l16 {padding-left: 0pt; }
 #l16> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l17 {padding-left: 0pt; }
 #l17> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l18 {padding-left: 0pt; }
 #l18> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l19 {padding-left: 0pt; }
 #l19> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l20 {padding-left: 0pt; }
 #l20> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l21 {padding-left: 0pt; }
 #l21> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l22 {padding-left: 0pt; }
 #l22> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l23 {padding-left: 0pt; }
 #l23> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l24 {padding-left: 0pt; }
 #l24> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l25 {padding-left: 0pt; }
 #l25> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l26 {padding-left: 0pt; }
 #l26> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l27 {padding-left: 0pt; }
 #l27> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l28 {padding-left: 0pt; }
 #l28> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l29 {padding-left: 0pt; }
 #l29> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l30 {padding-left: 0pt; }
 #l30> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l31 {padding-left: 0pt; }
 #l31> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l32 {padding-left: 0pt; }
 #l32> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l33 {padding-left: 0pt; }
 #l33> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l34 {padding-left: 0pt; }
 #l34> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l35 {padding-left: 0pt; }
 #l35> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l36 {padding-left: 0pt; }
 #l36> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 li {display: block; }
 #l37 {padding-left: 0pt; }
 #l37> li>*:first-child:before {content: "• "; color: black; font-family:"Calibri Light", sans-serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
</style></head><body><p class="s1" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">TCP - strumieniowe</p><p class="s2" style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;"><span class="s3" style=" background-color: #F00;">Wypełnienie struktury sockaddr_in/sockaddr_in6 portem oraz adresacją IPv4/v6 //BEZ DNS</span><span class="p"> </span><span class="s4" style=" background-color: #0F0;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</span></p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Socket() - stworzenie gniazd, ustawić SOCK_STREAM</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s5" style=" background-color: #FF0;">setsockopt()</span></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Connect()</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Write() – pisanie do gniazda Read() – czytanie z gniazda Close() – zakończenie polaczenia</p><p class="s2" style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;"><span class="s3" style=" background-color: #F00;">Wypełnienie struktury sockaddr_in/sockaddr_in6 portem oraz adresacją IPv4/v6 //BEZ DNS</span><span class="p"> </span><span class="s4" style=" background-color: #0F0;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</span><span class="p"> </span><span class="s4" style=" background-color: #0F0;">accept(), addr = null, service = (nr portu), hints.af_family = AF_inet, hints.socktype = sock_stream // Z</span><span class="p"> </span><span class="s4" style=" background-color: #0F0;">DNS</span></p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Socket() - stworzenie gniazd, ustawić SOCK_STREAM</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s5" style=" background-color: #FF0;">setsockopt()</span></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Bind() - połączenie danych ze struktury z portem</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Listen() - nasłuchiwanie</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Accept() – akceptacja polaczenia na gnieździe</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;"><span class="s5" style=" background-color: #FF0;">Fork() – podział na potomka i rodzica tylko jeśli serwer współbieżny</span><span class="p"> </span><span class="s5" style=" background-color: #FF0;">(dodatkowo trzeba obsłużyć lub</span><span class="p"> </span><span class="s5" style=" background-color: #FF0;">jawnie zignorować sygnał SIGCHILD)</span></p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Write() – pisanie do gniazda Read() – czytanie z gniazda Close() – zakończenie polaczenia</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s6" style=" background-color: #D2D2D2;">TCP zabezpiecza przed utratą pakietów</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">UDP - datagramowe</p><p class="s2" style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s5" style=" background-color: #FF0;">Należy poprosić serwer o dowiązanie do grupy multicastowej</span><span class="p"> – jeśli multicast</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s3" style=" background-color: #F00;">Wypełnienie struktury sockaddr_in6 portem 131 oraz adresacją IPv6 //BEZ DNS</span></p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s4" style=" background-color: #0F0;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</span></p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Ustawić opcję</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">socket() - stworzenie gniazda, SOCK_DGRAM</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s5" style=" background-color: #FF0;">setsockopt() – SO_BROADCAST (jeśli broadcast)</span></p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s5" style=" background-color: #FF0;">Ustawić opcję multicast</span><span class="p"> – jeśli multicast</span></p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">bind() - połączeni portu z strukturą adresową</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">rcvfrom() - odebranie informacji ode serwera close() – zamykanie polaczenia</p><p class="s2" style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s5" style=" background-color: #FF0;">Dowiązuje hosta do grupy multicastowej</span><span class="p"> – jeśli ma być multicast</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s3" style=" background-color: #F00;">Wypełnienie struktury sockaddr_in6 portem 131 oraz adresacją IPv6 //BEZ DNS</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;line-height: 13pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="text-indent: 0pt;line-height: 13pt;text-align: left;">accept(), addr = null, service = 131, hints.af_family = AF_inet6, hints.socktype = sock_dgram // Z DNS</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">socket() - stworzenie gniazda, SOCK_DGRAM</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s5" style=" background-color: #FF0;">setsockopt() - ustawienie opcji SO_BROADCAST</span><span class="p"> (jeśli broadcast)</span></p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 22pt;text-align: left;"><span class="s5" style=" background-color: #FF0;">Ustawić opcję multicast</span><span class="p"> – jeśli multicast rcvfrom() - odebranie informacji sendto() - wysłanie informacji</span></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 13pt;text-align: left;">close() – zamykanie polaczenia</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">SCTP - sekwencyjne</p><p class="s2" style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s3" style=" background-color: #F00;">Wypełnienie struktury sockaddr_in6 portem 130 oraz adresacją IPv6 //BEZ DNS</span></p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;"><span class="s4" style=" background-color: #0F0;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</span><span class="p"> socket() - stworzenie gniazda, SOCK_SEQPACK/SOCK_STREAM oraz protkół SCTP</span></p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 12pt;text-align: left;"><span class="s5" style=" background-color: #FF0;">setsockopt()</span></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">sctp_sendmsg() - pisanie do gniazda sctp_recvmsg() - czytanie z gniazda</p><p class="s2" style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s3" style=" background-color: #F00;">Wypełnienie struktury sockaddr_in6 portem 103 oraz adresacją IPv6 //BEZ DNS</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;line-height: 13pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="text-indent: 0pt;line-height: 13pt;text-align: left;">accept(), addr = null, service = 103, hints.af_family = AF_inet6, hints.socktype = sock_seqpack // Z DNS</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">socket() - stworzenie gniazda, SOCK_SEQPACK/ SOCK_STREAM oraz protokół SCTP</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s5" style=" background-color: #FF0;">setsockopt()</span></p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;"><span class="s5" style=" background-color: #FF0;">fork() - podział na rodzica i potomka (tylko jeśli ma być współbieżny)</span><span class="p"> </span><span class="s5" style=" background-color: #FF0;">(dodatkowo trzeba obsłużyć lub</span><span class="p"> </span><span class="s5" style=" background-color: #FF0;">jawnie zignorować sygnał SIGCHILD)</span></p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda sctp_sendmsg() - pisanie do gniazda close() - zamknięcie połączenia</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s6" style=" background-color: #D2D2D2;">W sctp SOCK_SEQPACK zabezpiecza przed utratą pakietów</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-left: 5pt;text-indent: 0pt;text-align: left;">GNIAZDA RAW</p><p class="s7" style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Rodzina AF_INET</p><p class="s8" style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s4" style=" background-color: #0F0;">Wypełnienie struktury adresowej sockaddr_in6</span></p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">socket() - stworzenie gniazda z opcją gniazd surowych IPPROTO_RAW i rodziną gniazd AF_INET6</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">connect() - połączenie sendto() - wysłanie danych recv() - odebranie danych</p><p class="s8" style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s4" style=" background-color: #0F0;">Wypełnienie struktury adresowej sockaddr_in/sockaddr_in6</span></p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">socket() - stworzenie gniazda z opcją gniazd surowych IPPROTO_RAW i rodziną gniazd</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">AF_INET/AF_INET6</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">bind() - połączenie portu z strukturą adresową</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">listen() - ustawienie nasłuchiwania</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;"><span class="s5" style=" background-color: #FF0;">fork() – podział na rodzica i potomka (tylko jeśli ma być współbieżny)</span><span class="p"> </span><span class="s5" style=" background-color: #FF0;">(dodatkowo trzeba obsłużyć lub</span><span class="p"> </span><span class="s5" style=" background-color: #FF0;">jawnie zignorować sygnał SIGCHILD)</span></p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">recv() - odebranie danych od klienta</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">sendto() - wysłanie danych do gniazda surowego</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">close() - zamknięcie gniazda</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s1" style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">PF_PACKET</p><p class="s7" style="padding-top: 3pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">DATAGRAMOWE</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s5" style=" background-color: #FF0;">Należy stworzyć grupę multicastową i dowiązywać do niej zainteresowane hosty</span><span class="p"> – jeśli multicast</span></p><p class="s8" style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s4" style=" background-color: #0F0;">Wypełnienie struktury adresowej sockaddr_ll</span></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">socket(PF_PACKET, SOCK_DGRAM, protokół) - stworzenie gniazda PF_PACKET</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;"><span class="s5" style=" background-color: #FF0;">setsockopt(PACKET_MR_MULTICAST) z wypełnioną strukturą packer_mreq ustawioną na konkretną</span><span class="p"> </span><span class="s5" style=" background-color: #FF0;">grupę multicastową</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s5" style=" background-color: #FF0;">setsockopt() - ustawić SO_BROADCAST</span><span class="p"> – jeśli broadcast</span></p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">recvmsg() - oczekiwanie na zapytanie od klienta i zebranie adresu klienta ze struktury sockaddr_II sendmsg() - odesłanie informacji do klienta</p><p class="s8" style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s4" style=" background-color: #0F0;">wypełnienie struktury sockaddr_ll z adresem i portem serwera.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s5" style=" background-color: #FF0;">sll_pkttype w strukturze sockaddr_II ustawić na PACKET_BROADCAST</span><span class="p"> – jeśli broadcast</span></p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">socket(PF_PACKET, SOCK_DGRAM, protokół) - stworzenie gniazda PF_PACKET</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;"><span class="s5" style=" background-color: #FF0;">setsockopt(PACKET_MR_MULTICAST) z wypełnioną strukturą packer_mreq ustawioną na konkretną</span><span class="p"> </span><span class="s5" style=" background-color: #FF0;">grupę multicastową</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;"><span class="s5" style=" background-color: #FF0;">setsockopt() - ustawić SO_BROADCAST</span><span class="p"> sendmsg() - wysłanie zapytania do serwera</span></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">recvmsg() - oczekiwanie na odpowiedź od serwera</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><span class="s6" style=" background-color: #D2D2D2;">Nie ma zabezpieczenia. SOCK_DGRAM, PF_PACKET - usługa bezpołączeniowa</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l1"><li data-list-text="1."><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi ECHO działającej na porcie 104 dla IPv6 z użyciem gniazd typu sekwencyjnego. Wykorzystaj API do DNS. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">nasłuchiwać na wybranych adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Może wystąpić sygnał SIGCHLD który należy obsłużyć lub jawnie zignorować</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l2"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 104 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_SEQPACK oraz protkół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 104 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 104, hints.af_family = AF_inet6, hints.socktype = sock_seqpack // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_SEQPACK oraz protokół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">fork() - podział na rodzica i potomka</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie połączenia</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Zabezpieczenie: SOCK_SEQPACK zabezpiecza przed utratą pakietów</p></li></ul></li><li data-list-text="2."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi ECHO działającej na porcie 111 dla IPv4. Program serwera powinien korzystać z jednego gniazda nasłuchującego i umożliwiać dla klientów z parzystym ostatnim bajtem adresu IP obsługę w sposób iteracyjny, natomiast dla klientów z nieparzystym ostatnim bajtem adresu IP obsługę w sposób współbieżny. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji (jednym lub więcej). (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">Język PYTHON TCP - niezawodny Klient :</p><ul id="l3"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">s.connect((&lt;adressipv4 serwera&gt;, 111))</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">s.send(b&#39;Hello, world&#39;)</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">data = s.recv(1024)</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">s.close()</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer :</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR,1)</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">s.bind((&lt;adresipv4&gt;, 111))</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">s.listen(1)</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">whileTrue:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">conn, addr = s.accept()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">print(&#39;Connected by&#39;, addr)</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">data = conn.recv(1024)</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">conn.send(data)</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">conn.close()</p></li></ul></li><li data-list-text="3."><p style="padding-top: 9pt;padding-left: 16pt;text-indent: -10pt;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi typu ECHO działającej na</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">gniazdach z rodziny PF_PACKET. Serwer powinien nasłuchiwać na wszystkich interfejsach sieciowych stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">dostępu do gniazd można użyć? Czy w programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l4"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury adresowe sockaddr_II</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury adresowej sockaddr_ll</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą ramek</p></li></ul></li><li data-list-text="4."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi ECHO działającej na porcie 128 dla IPv6 z użyciem gniazd typu datagramowego. Wykorzystaj API do DNS. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">UDP -zawodny Klient:</p><ul id="l5"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 128 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić SOCK_DGRAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie portu z strukturą adresową</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - odebranie informacji od serwera</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 126 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null, service = 128,</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">hints.af_family = AF_inet6, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić SOCK_DGRAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - odebranie informacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą bramek</p></li></ul></li><li data-list-text="5."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi typu ECHO działającej na gniazdach z rodziny PF_PACKET i obsługujących adresację typu broadcast. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">nasłuchiwać na wszystkich interfejsach sieciowych stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy w</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l6"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sll_pkttype w strukturze sockaddr_II ustawić na PACKET_BROADCAST</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_BROADCAST</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_BROADCAST</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą ramek</p></li></ul></li><li data-list-text="6."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi ECHO działającej na porcie 112 dla IPv6. Program serwera powinien korzystać z jednego gniazda nasłuchującego i umożliwiać dla klientów z parzystym ostatnim bajtem adresu IP obsługę w sposób iteracyjny, natomiast dla klientów z</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 13pt;text-align: left;">nieparzystym ostatnim bajtem adresu IP obsługę w sposób współbieżny. Wykorzystaj API do DNS.</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Serwer powinien nasłuchiwać na wybranych adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd,</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Zarys: Należy stworzyć połączenie typu one-to-many, gdzie serwer na jednym gnieździe będzie korzystając z wielu asocjacji jednocześnie obsługiwał iteracyjnie klientów z bajtem parzystym i współbieżnie klientów z nieparzystym bajtem. Sprawdzanie ostatniego bajtu IP klienta można zrealizować za pomocą instrukcji warunkowej “if” w serwerze.</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Może wystąpić sygnał SIGCHLD który należy obsłużyć lub jawnie zignorować</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l7"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 112 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_STREAM oraz protkół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 112 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 112, hints.af_family = AF_inet6, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_STREAM oraz protokół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">if - sprawdzanie parzystości ostatniego bajtu ip klienta</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">fork() - podział na rodzica i potomka</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie połączenia</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Zabezpieczenie: SOCK_STREAM zabezpiecza przed utratą pakietów</p></li></ul></li><li data-list-text="7."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi DAYTIME działającej na porcie 116 dla IPv6 z użyciem gniazd typu datagramowego. Wykorzystaj API do DNS. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">UDP - zawodny Klient:</p><ul id="l8"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 116 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić SOCK_DGRAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie portu z strukturą adresową</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">recvfrom() - odebranie informacji ode serwera Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 116 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null, service = 116,</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">hints.af_family = AF_inet6, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić SOCK_DGRAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - odebranie informacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą bramek</p></li></ul></li><li data-list-text="8."><p style="padding-top: 9pt;padding-left: 16pt;text-indent: -10pt;text-align: justify;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi DAYTIME działającej na</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">porcie 136 dla IPv6 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: justify;">serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">TCP - niezawodny</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Może wystąpić sygnał SIGCHLD, który należy obsłużyć lub jawnie zignorować</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l9"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">Wypełnienie struktury sockaddr_in6 portem 136 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">connect()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">read() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 136 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 136, hints.af_family = AF_inet6, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">bind()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">listen() - nasłuchiwanie na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">accept()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">fork() - podział na proces potomka i rodzica</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">read() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">close()</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">ODP: jest zabezpieczenie przed utratą pakietów (TCP)</p></li></ul></li><li data-list-text="9."><p style="padding-top: 9pt;padding-left: 16pt;text-indent: -10pt;text-align: justify;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi DAYTIME działającej na</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: justify;">porcie 131 dla IPv4 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">TCP - niezawodny</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Może wystąpić sygnał SIGCHLD, który należy obsłużyć lub jawnie zignorować</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l10"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">Wypełnienie struktury sockaddr_in portem 131 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">connect()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">read() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 131 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 131, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - nasłuchiwanie na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">fork() - podział na proces potomka i rodzica</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close()</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">ODP: jest zabezpieczenie przed utratą pakietów (TCP)</p></li></ul></li><li data-list-text="10."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi DAYTIME działającej na porcie 116 dla IPv6. Program serwera powinien korzystać z jednego gniazda, z którego jest możliwość także inicjowania nowych połączeń. Klient nie powinien mieć możliwości odbierania pakietów dla połączeń,</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">które nie zestawił. Wybierz odpowiedni protokół transportowy: UDP, TCP lub SCTP. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">SCTP - niezawodny Klient:</p><ul id="l11"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 116 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, protkół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 116 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 116, hints.af_family = AF_inet6, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, protokół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul></li><li data-list-text="11."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: justify;">Opisz strukturę programów klienta i serwera dla usługi DAYTIME działającej na porcie 122 dla IPv6, obsługującej adresację typu multicast. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">UDP - zawodny Serwer:</p><ul id="l12"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Dowiązuje hosta do grupy multicastowej</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 122 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Ustawić opcję multicast</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">Setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - powiązanie portu ze strukturą</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie wiadomości do gniazda</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Należy poprosić serwer o dowiązanie do grupy multicastowej</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 122 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null, service = 122,</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">hints.af_family = AF_inet6, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Ustawić opcję multicast</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - otrzymanie wiadomości z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie gniazda</p></li></ul></li><li data-list-text="12."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi DAYTIME działającej na porcie 102 dla IPv4 z użyciem gniazd typu sekwencyjnego. Wykorzystaj API do DNS. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">nasłuchiwać na wybranych adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji.</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l13"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 102 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_SEQPACK oraz protkół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 102 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 102, hints.af_family = AF_inet, hints.socktype = sock_seqpack // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_SEQPACK oraz protokół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie połączenia</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Zabezpieczenie: SOCK_SEQPACK zabezpiecza przed utratą pakietów</p></li></ul></li><li data-list-text="13."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi ECHO działającej na porcie 124 dla IPv6 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">TCP - niezwodny Serwer:</p><ul id="l14"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Musimy obsługiwać sygnał SIGCHLD. W przeciwnym razie będą powstawać Zombie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 124 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 124, hints.af_family = AF_inet6, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket(AF_INET6, SOCK_STREAM, 0)) /dla adresów IPv6, typ strumieniowy</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt(...,...,SO_REUSEADDR) - może to pomoże z nasłuchiwaniem na wszystkich adresach stacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - nasłuchiwanie na porcie --&gt; jak zrobić nasłuchiwanie wszędzie, na wszystkich adresach</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">stacji?</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">signal(SIGCHLD, sig_chld); → w handlerze funkcją waitpid() zabijamy zakończone procesy potomka</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">fork() - podział na proces potomka i rodzica</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close()</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 124 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">read() - czytanie z gniazda</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">ODP: jest zabezpieczenie przed utratą pakietów (TCP)</p></li></ul></li><li data-list-text="14."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi typu ECHO działającej na gniazdach z rodziny PF_PACKET i obsługujących adresację typu multicast. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">nasłuchiwać na wybranym interfejsie sieciowym stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy w programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Należy stworzyć grupę multicastową i dowiązywać do niej zainteresowane hosty</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p><ul id="l15"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket(PF_PACKET, SOCK_DGRAM, protokół) - stworzenie gniazda PF_PACKET</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt(PACKET_MR_MULTICAST) z wypełnioną strukturą packer_mreq ustawioną na konkretną</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">grupę multicastową</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvmsg() - oczekiwanie na zapytanie od klienta i zebranie adresu klienta ze struktury sockaddr_II</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendmsg() - odesłanie informacji do klienta</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket(PF_PACKET, SOCK_DGRAM, protokół) - stworzenie gniazda PF_PACKET</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt(PACKET_MR_MULTICAST) z wypełnioną strukturą packer_mreq ustawioną na konkretną</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">grupę multicastową</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">wypełnienie struktury sockaddr_in z adresem i portem serwera.</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendmsg() - wysłanie zapytania do serwera</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvmsg() - oczekiwanie na odpowiedź od serwera</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">ODP: Nie ma zabezpieczenia. SOCK_DGRAM, PF_PACKET - usługa bezpołączeniowa</p></li></ul></li><li data-list-text="15."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi DAYTIME działającej na porcie 118 dla IPv6 z użyciem gniazd typu datagramowego. Wykorzystaj API do DNS. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">UDP -zawodny Klient:</p><ul id="l16"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 118 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić SOCK_DGRAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie portu z strukturą adresową</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">recvfrom() - odebranie informacji od serwera Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 118 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null, service = 118,</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">hints.af_family = AF_inet6, hints.socktype = sock_dgram// Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić SOCK_DGRAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - odebranie informacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą bramek</p></li></ul></li><li data-list-text="16."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi ECHO działającej na porcie 103 dla IPv6 z użyciem gniazd typu sekwencyjnego. Wykorzystaj API do DNS. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: left;">nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Może wystąpić sygnał SIGCHLD który należy obsłużyć lub jawnie zignorować</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l17"><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 130 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_SEQPACK oraz protkół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 103 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 103, hints.af_family = AF_inet6, hints.socktype = sock_seqpack // Z</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_SEQPACK oraz protokół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">fork() - podział na rodzica i potomka</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie połączenia</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Zabezpieczenie: SOCK_SEQPACK zabezpiecza przed utratą pakietów</p></li></ul></li><li data-list-text="17."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi ECHO działającej na porcie 123 dla IPv4 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: left;">najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p><ul id="l18"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Musimy obsługiwać sygnał SIGCHLD. W przeciwnym razie będą powstawać Zombie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 123 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 123, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket(AF_INET, SOCK_STREAM, 0)) /dla adresów IPv6, typ strumieniowy</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt(...,...,SO_REUSEADDR) - może to pomoże z nasłuchiwaniem na wszystkich adresach stacji</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - nasłuchiwanie na porcie -&gt; jak zrobić nasłuchiwanie wszędzie, na wszystkich adresach</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">stacji?</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">signal(SIGCHLD, sig_chld); → w handlerze funkcją waitpid() zabijamy zakończone procesy potomka</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">fork() - podział na proces potomka i rodzica</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close()</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 124 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">ODP: Jest zabezpieczenie przed utratą pakietów (TCP)</p></li></ul></li><li data-list-text="18."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: justify;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi DAYTIME działającej na porcie 125 dla IPv4 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: justify;">serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">TCP - niezawodny Klient:</p><ul id="l19"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 125 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">read() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 125 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 125, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - wypełnić SOCK_STREAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - nasłuchiwanie na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close()</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">ODP: jest zabezpieczenie przed utratą pakietów (TCP)</p></li></ul></li><li data-list-text="19."><p style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi DAYTIME działającej na porcie 109 dla IPv4.</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: left;">Program serwera powinien korzystać z jednego gniazda nasłuchującego i umożliwiać dla klientów z parzystym ostatnim bajtem adresu IP obsługę w sposób iteracyjny, natomiast dla klientów z</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">nieparzystym ostatnim bajtem adresu IP obsługę w sposób współbieżny. Wybierz odpowiedni protokół transportowy: UDP, TCP lub SCTP. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">wybranych adresach stacji (jednym lub więcej). (Jakie funkcje sieciowe należy wywołać po stronie</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: justify;">serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Zarys: Należy stworzyć połączenie typu one-to-many, gdzie serwer na jednym gnieździe będzie korzystając z wielu asocjacji jednocześnie obsługiwał iteracyjnie klientów z bajtem parzystym i współbieżnie klientów z nieparzystym bajtem. Sprawdzanie ostatniego bajtu IP klienta można zrealizować za pomocą instrukcji warunkowej “if” w serwerze.</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Może wystąpić sygnał SIGCHLD który należy obsłużyć lub jawnie zignorować</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l20"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 109 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_STREAM oraz protkół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 109 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 109, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_STREAM oraz protokół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">if - sprawdzanie parzystości ostatniego bajtu ip klienta</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">fork() - podział na rodzica i potomka</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie połączenia</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Zabezpieczenie: SOCK_STREAM zabezpiecza przed utratą pakietów</p></li></ul></li><li data-list-text="20."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: justify;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi ECHO działającej na porcie 128 dla IPv6 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: justify;">serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p><ul id="l21"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Musimy obsługiwać sygnał SIGCHLD albo jawnie zignorować. W przeciwnym razie będą powstawać</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Zombie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 128 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 125, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">signal(SIGCHLD, sig_chld); → w handlerze funkcją waitpid() zabijamy zakończone procesy potomka</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie portu z strukturą adresową</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept z forkiem()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie nowego gniazda tcp dla dziecka</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recv()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">send()</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 128 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket(), tak jak w serwerze</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">send()</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recv()</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">ODP: NIE PONIEWAŻ TCP</p></li></ul></li><li data-list-text="21."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi typu DAYTIME działającej na gniazdach z rodziny PF_PACKET i obsługujących adresację typu broadcast. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">nasłuchiwać na wybranym interfejsie sieciowym stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy w</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: left;">programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l22"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sll_pkttype w strukturze sockaddr_II ustawić na PACKET_BROADCAST</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_BROADCAST</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_BROADCAST</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą ramek</p></li></ul></li><li data-list-text="22."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Jak zrealizowałbyś program serwera współbieżnego dla usługi typu DAYTIME działającej na gniazdach z rodziny PF_PACKET. Jakie ograniczenia w liczbie obsługiwanych klientów będą obowiązywać. (Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne,</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy w programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l23"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_BROADCAST</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - ustawić PF_PACKET</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_BROADCAST</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - otrzymanie wiadomości</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">ODP: Nie ma mechanizmu zabezpieczającego przed utratą ramek</p></li></ul></li><li data-list-text="23."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi ECHO działającej na porcie 131 dla IPv6, obsługującej adresację typu multicast. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">UDP - zawodny Serwer:</p><ul id="l24"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Dowiązuje hosta do grupy multicastowej</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 131 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 131, hints.af_family = AF_inet6, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Ustawić opcję multicast</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - powiązanie portu ze strukturą</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - otrzymanie wiadomości z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie wiadomości do gniazda</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Należy poprosić serwer o dowiązanie do grupy multicastowej</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 131 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Ustawić opcję multicast</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie wiadomości do gniazda</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - otrzymanie wiadomości z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie gniazda</p></li></ul></li><li data-list-text="24."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi ECHO działającej na porcie 113 dla IPv4. Program serwera powinien korzystać z jednego gniazda, z którego jest możliwość także</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">inicjowania nowych połączeń. Klient nie powinien mieć możliwości odbierania pakietów dla połączeń, które nie zestawił. Wybierz odpowiedni protokół transportowy: UDP, TCP lub SCTP. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">SCTP - niezawodny Klient:</p><ul id="l25"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 133 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, protkół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 113 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 113, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, protokół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul></li><li data-list-text="25."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi DAYTIME działającej na porcie 135 dla IPv4 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne,</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">W serwerze może wystąpić sygnał SIGCHLD, który należy obsłużyć lub jawnie zignorować</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">TCP - niezawodny Klient:</p><ul id="l26"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 135 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazd, Ustawić SOCK_STREAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">read() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 135 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 135, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda,Ustawić SOCK_STREAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">fork() - podział na proces rodzica i potomka</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul></li><li data-list-text="26."><p style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi ECHO działającej na porcie 134,</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">obsługującej adresację typu broadcast. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wszystkich adresach IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">UDP - zawodne Klient:</p><ul id="l27"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 134 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_DGRAM</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączeni portu z strukturą adresową</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">rcvfrom() - odebranie informacji ode serwera Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 134 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null, service = 134,</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">hints.af_family = AF_inet, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_DGRAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawienie opcji SO_BROADCAST</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">rcvfrom() - odebranie informacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie informacji</p></li></ul></li><li data-list-text="27."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi typu ECHO działającej na gniazdach z rodziny AF_INET6 typu RAW. Serwer powinien nasłuchiwać na wybranym adresie sieciowym stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">mechanizm multipleksacji dostępu do gniazd można użyć? Czy w programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p><ul id="l28"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury adresowej sockaddr_in6</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda z opcją gniazd surowych IPPROTO_RAW i rodziną gniazd AF_INET6</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie portu z strukturą adresową</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recv() - odebranie danych od klienta</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie danych do gniazda surowego</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie gniazda</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury adresowej sockaddr_in6</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda z opcją gniazd surowych IPPROTO_RAW i rodziną gniazd AF_INET6</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie danych</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recv() - odebranie danych</p></li></ul></li><li data-list-text="28."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi DAYTIME działającej na porcie 115 dla IPv4. Program serwera powinien korzystać z jednego gniazda, z którego jest możliwość także</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">inicjowania nowych połączeń. Klient nie powinien mieć możliwości odbierania pakietów dla połączeń, które nie zestawił. Wybierz odpowiedni protokół transportowy: UDP, TCP lub SCTP. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">SCTP - niezawodny Klient:</p><ul id="l29"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 115 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, protkół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 115 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 115, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 7pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, protokół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li></ul></li><li data-list-text="29."><p style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi ECHO działającej na porcie 133,</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: left;">obsługującej adresację typu broadcast. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">UDP - zawodny Klient:</p><ul id="l30"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 133 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Socket() – stworzenie gniazda</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Setsockopt() – użyjemy do ustawienia opcji SO_BROADCAST</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Sendto() – wysłanie na broadcast</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">Recvfrom() – odebranie informacji Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 133 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null, service = 133,</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">hints.af_family = AF_inet, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Socket() – stworzenie gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Bind() – połączenia portu ze strukturą danych</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Recvfrom() – otrzymanie informacji</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Sendto() – wysłanie informacji</p></li></ul></li><li data-list-text="30."><p style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi ECHO działającej na porcie 129</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">dla IPv4 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 107%;text-align: left;">nasłuchiwać na wszystkich adresach stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji.</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">SCTP - niezawodny Klient:</p><ul id="l31"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 129 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, protkół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 129 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 129, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, protokół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul></li><li data-list-text="31."><p style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi DAYTIME działającej na porcie 123,</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">obsługującej adresację typu broadcast. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy i rodziny adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">UDP - zawodny Klient:</p><ul id="l32"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 123 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Bind() - połączenie portu ze strukturą adresową</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">Recvfrom() – odebranie informacji od serwera Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 123 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null, service = 123,</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">hints.af_family = AF_inet, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Socket() – stworzeni gniazda o typie SOCK_DGRAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnić strukture adresową sockaddr</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Setsockopt() - ustawic opcję SO_BROADCAST</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Sendto() – wysłanie informacji</p></li></ul></li><li data-list-text="32."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi ECHO działającej na porcie 108 dla IPv6. Program serwera powinien korzystać z jednego gniazda, z którego jest możliwość także</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">inicjowania nowych połączeń. Wybierz odpowiedni protokół transportowy: UDP, TCP lub SCTP.</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na wybranych adresach stacji (jednym lub więcej). (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">dostępu do gniazd można użyć? Czy wymagane są mechanizmy zabezpieczające przed utratą</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">pakietów?)</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">SCTP - niezawodny Klient:</p><ul id="l33"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 129 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, protkół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 108 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 108, hints.af_family = AF_inet6, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, protokół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_recvmsg() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul></li><li data-list-text="33."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Opisz strukturę programów klienta i serwera iteracyjnego dla usługi typu DAYTIME działającej na gniazdach z rodziny AF_INET typu RAW. Serwer powinien nasłuchiwać na wybranym adresie sieciowym stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy w programach można wykorzystać API do DNS. Czy wymagane są mechanizmy zabezpieczające przed utratą ramek?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Serwer:</p><ul id="l34"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury adresowej sockaddr_in</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda z opcją gniazd surowych IPPROTO_RAW i rodziną gniazd AF_INET</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie portu z strukturą adresową</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie danych do gniazda surowego</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie gniazda</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury adresowej sockaddr_in</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda z opcją gniazd surowych IPPROTO_RAW i rodziną gniazd AF_INET</p></li><li data-list-text="•"><p style="padding-top: 1pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recv() - odebranie danych</p></li></ul></li><li data-list-text="34."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: justify;">Opisz strukturę programów klienta i serwera dla usługi DAYTIME działającej na porcie 120 dla IPv4, obsługującej adresację typu multicast. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie serwera i klienta. Opisz</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;line-height: 168%;text-align: left;">UDP - zawodny Serwer:</p><ul id="l35"><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;line-height: 13pt;text-align: left;">Dowiązuje hosta do grupy multicastowej</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 120 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Ustawić opcję multicast</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: justify;">Setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - powiązanie portu ze strukturą</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sendto() - wysłanie wiadomości do gniazda</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Należy poprosić serwer o dowiązanie do grupy multicastowej</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 120 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, addr = null, service = 120,</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">hints.af_family = AF_inet, hints.socktype = sock_dgram // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Ustawić opcję multicast</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">recvfrom() - otrzymanie wiadomości z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie gniazda</p></li></ul></li><li data-list-text="35."><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: justify;">Opisz strukturę programów klienta i serwera współbieżnego dla usługi ECHO działającej na porcie 127 dla IPv4 z użyciem gniazd typu strumieniowego. Wykorzystaj API do DNS. Serwer powinien</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">nasłuchiwać tylko na jednym adresie IP stacji. (Jakie funkcje sieciowe należy wywołać po stronie</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: justify;">serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Czy wymagane są mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 8pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">W serwerze może wystąpić sygnał SIGCHLD, który należy obsłużyć lub jawnie zignorować</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">TCP - niezawodny</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l36"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 127 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, Ustawić SOCK_STREAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">read() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in portem 127 oraz adresacją IPv4 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i accept(), addr = null, service = 127, hints.af_family = AF_inet, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 7pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Ustawić SOCK_STREAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazd, ustawić SOCK_STREAM</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">fork() - podział na proces rodzica i potomka</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">read() - czytanie z gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">write() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul></li><li data-list-text="36."><p style="padding-top: 9pt;padding-left: 22pt;text-indent: -16pt;text-align: left;">Opisz strukturę programów klienta i serwera dla usługi DAYTIME działającej na porcie 110 dla IPv6.</p></li></ol><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">Program serwera powinien korzystać z jednego gniazda nasłuchującego i umożliwiać dla klientów z parzystym ostatnim bajtem adresu IP obsługę w sposób iteracyjny, natomiast dla klientów z</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: left;">nieparzystym ostatnim bajtem adresu IP obsługę w sposób współbieżny. Wybierz odpowiedni protokół transportowy: UDP, TCP lub SCTP. Wykorzystaj API do DNS. Serwer powinien nasłuchiwać na</p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">wybranych adresach stacji (jednym lub więcej). (Jakie funkcje sieciowe należy wywołać po stronie</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: justify;">serwera i klienta. Opisz podstawowe funkcje sieciowe, za co wywoływane funkcje są odpowiedzialne, wymień najważniejsze struktury danych, które należy użyć, wymagane typy gniazd, obsługiwane typy adresacji. Jaki mechanizm multipleksacji dostępu do gniazd można użyć? Czy wymagane są</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">mechanizmy zabezpieczające przed utratą pakietów?)</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">SCTP - niezawodny</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: justify;">Zarys: Należy stworzyć połączenie typu one-to-many, gdzie serwer na jednym gnieździe będzie korzystając z wielu asocjacji jednocześnie obsługiwał iteracyjnie klientów z bajtem parzystym i współbieżnie klientów z nieparzystym bajtem. Sprawdzanie ostatniego bajtu IP klienta można</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 108%;text-align: justify;">zrealizować za pomocą instrukcji warunkowej “if” w serwerze. Może wystąpić sygnał SIGCHLD który należy obsłużyć lub jawnie zignorować</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Klient:</p><ul id="l37"><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 110 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - addr - adres serwera, service - port serwera, reszta tak jak w serwerze //Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_STREAM oraz protkół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">connect() - połączenie gniazda z adresem określonym w strukturze</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;line-height: 167%;text-align: left;">sctp_recvmsg() - czytanie z gniazda Serwer:</p></li><li data-list-text="•"><p style="padding-left: 13pt;text-indent: -8pt;text-align: left;">Wypełnienie struktury sockaddr_in6 portem 110 oraz adresacją IPv6 //BEZ DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">getaddrinfo() - otrzymaj strukturę adresową serwera z portem i adresem, zdolną do listen() bind() i</p><p style="padding-top: 1pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">accept(), addr = null, service = 110, hints.af_family = AF_inet6, hints.socktype = sock_stream // Z DNS</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">socket() - stworzenie gniazda, SOCK_STREAM oraz protokół SCTP</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">setsockopt() - ustawić SO_REUSEADDR</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">bind() - połączenie danych ze struktury z portem</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">listen() - ustawienie nasłuchiwania na porcie</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">accept() - akceptacja połączenia na gnieździe</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">if - sprawdzanie parzystości ostatniego bajtu ip klienta</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">fork() - podział na rodzica i potomka</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">sctp_sendmsg() - pisanie do gniazda</p></li><li data-list-text="•"><p style="padding-top: 9pt;padding-left: 13pt;text-indent: -8pt;text-align: left;">close() - zamknięcie połączenia</p></li></ul><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Zabezpieczenie: SOCK_STREAM zabezpiecza przed utratą pakietów</p></body></html>
